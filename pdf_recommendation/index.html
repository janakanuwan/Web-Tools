<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recommendation Letter Generator</title>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #e9f0f9;
            --accent-color: #ff6b6b;
            --text-color: #333;
            --light-gray: #f5f5f5;
            --border-color: #ddd;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            color: var(--text-color);
            line-height: 1.6;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #f8f9fa;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 20px;
            text-align: center;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        @media (min-width: 768px) {
            .container {
                grid-template-columns: minmax(300px, 30%) 1fr;
            }
        }

        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .files-section, .search-section, .sample-files-section {
            margin-bottom: 25px;
        }

        h2 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--primary-color);
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 5px;
        }

        .file-input-container {
            position: relative;
            margin-bottom: 15px;
        }

        .custom-file-upload {
            display: block;
            width: 100%;
            padding: 10px 15px;
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        .custom-file-upload:hover {
            background-color: #3b5a8c;
        }

        /* Additional styles for the generator app */
        .preview-section {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        .document-preview {
            margin-top: 15px;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: white;
            min-height: 300px;
            white-space: pre-wrap;
            overflow-y: auto;
            max-height: 400px;
        }

        .placeholder {
            background-color: var(--secondary-color);
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .table-container {
            overflow-x: auto;
            margin-top: 20px;
            max-width: 100%;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            min-width: 650px; /* Ensures table has a minimum width */
        }

        th, td {
            padding: 10px;
            border: 1px solid var(--border-color);
            text-align: left;
            vertical-align: top;
        }

        th {
            background-color: var(--secondary-color);
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .table-actions {
            margin-top: 15px;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .btn:hover {
            background-color: #3b5a8c;
        }

        .btn-accent {
            background-color: var(--accent-color);
        }

        .btn-accent:hover {
            background-color: #e05151;
        }

        .btn-sm {
            padding: 5px 10px;
            font-size: 0.85rem;
        }

        .file-name {
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }

        .checkbox-container {
            margin-right: 10px;
        }

        textarea {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            min-height: 80px;
            resize: vertical;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        input[type="text"], input[type="date"] {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .status-message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
        }

        .success {
            background-color: #d4edda;
            color: #155724;
        }

        .error {
            background-color: #f8d7da;
            color: #721c24;
        }

        .warning {
            background-color: #fff3cd;
            color: #856404;
        }

        .hidden {
            display: none;
        }

        .progress-bar-container {
            width: 100%;
            height: 20px;
            background-color: var(--light-gray);
            border-radius: 10px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            width: 0%;
            transition: width 0.3s;
        }

        #outputContainer {
            display: none;
            margin-top: 20px;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--light-gray);
        }

        /* Styling for logs */
        .log-container {
            margin-top: 15px;
            padding: 10px;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }

        .log-entry {
            margin-bottom: 3px;
        }

        .log-info {
            color: #0077cc;
        }

        .log-success {
            color: #28a745;
        }

        .log-error {
            color: #dc3545;
        }

        /* Sample files section */
        .sample-files-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .sample-btn {
            font-size: 0.85rem;
            flex: 1;
            min-width: 120px;
        }
    </style>
</head>
<body>
    <h1>Recommendation Letter Generator</h1>
    
    <div class="container">
        <div class="controls">
            <div class="sample-files-section">
                <h2>Sample Files</h2>
                <div class="sample-files-buttons">
                    <button id="downloadTemplateBtn" class="btn sample-btn">Download Sample Template</button>
                    <button id="downloadExcelBtn" class="btn sample-btn">Download Sample Excel</button>
                </div>
            </div>
            
            <div class="files-section">
                <h2>Upload Files</h2>
                <div class="file-input-container">
                    <label for="wordTemplate" class="custom-file-upload">
                        Upload Word Template (.docx)
                    </label>
                    <input type="file" id="wordTemplate" accept=".docx" style="display: none;">
                    <div id="wordTemplateName" class="file-name"></div>
                </div>
                
                <div class="file-input-container">
                    <label for="excelData" class="custom-file-upload">
                        Upload Excel Data (.xlsx, .csv)
                    </label>
                    <input type="file" id="excelData" accept=".xlsx,.csv" style="display: none;">
                    <div id="excelDataName" class="file-name"></div>
                </div>
            </div>
            
            <div class="options-section">
                <h2>Actions</h2>
                <button id="addRowBtn" class="btn" disabled>Add Row</button>
                <button id="selectAllBtn" class="btn" disabled>Select All</button>
                <button id="deselectAllBtn" class="btn" disabled>Deselect All</button>
                <button id="generateDocsBtn" class="btn btn-accent" disabled>Generate Selected Documents</button>
                <div id="progressBarContainer" class="progress-bar-container hidden">
                    <div id="progressBar" class="progress-bar"></div>
                </div>
            </div>
            
            <div id="statusMessage" class="status-message hidden"></div>
            
            <div id="logContainer" class="log-container hidden">
                <div id="logEntries"></div>
            </div>
        </div>
        
        <div class="preview-section">
            <h2>Template Preview</h2>
            <div id="documentPreview" class="document-preview">
                <p>Upload a Word template to see preview here.</p>
            </div>
            
            <h2>Placeholder Values</h2>
            <div class="table-container">
                <table id="placeholderTable">
                    <thead>
                        <tr>
                            <th><input type="checkbox" id="selectAllCheckbox"></th>
                            <th>Actions</th>
                            <!-- Placeholder headers will be added dynamically -->
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Table rows will be added dynamically -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/mammoth@1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <script>
        // Global variables
        let placeholders = [];
        let placeholderDisplayNames = {}; // Map XML placeholders to display names
        let wordDocx = null;
        let wordContent = '';
        let excelData = [];
        let tableData = [];
        let zipContent = null; // Store the entire docx zip
        
        // Sample file paths (instead of content)
        const sampleTemplatePath = "RecommendationLetter_Template.docx";
        const sampleExcelPath = "Applications-details.xlsx";

        // DOM elements
        const wordTemplateInput = document.getElementById('wordTemplate');
        const wordTemplateName = document.getElementById('wordTemplateName');
        const excelDataInput = document.getElementById('excelData');
        const excelDataName = document.getElementById('excelDataName');
        const documentPreview = document.getElementById('documentPreview');
        const placeholderTable = document.getElementById('placeholderTable');
        const addRowBtn = document.getElementById('addRowBtn');
        const selectAllBtn = document.getElementById('selectAllBtn');
        const deselectAllBtn = document.getElementById('deselectAllBtn');
        const generateDocsBtn = document.getElementById('generateDocsBtn');
        const statusMessage = document.getElementById('statusMessage');
        const selectAllCheckbox = document.getElementById('selectAllCheckbox');
        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressBar = document.getElementById('progressBar');
        const logContainer = document.getElementById('logContainer');
        const logEntries = document.getElementById('logEntries');
        const downloadTemplateBtn = document.getElementById('downloadTemplateBtn');
        const downloadExcelBtn = document.getElementById('downloadExcelBtn');

        // Event listeners
        wordTemplateInput.addEventListener('change', handleWordTemplateUpload);
        excelDataInput.addEventListener('change', handleExcelDataUpload);
        addRowBtn.addEventListener('click', addEmptyRow);
        selectAllBtn.addEventListener('click', selectAllRows);
        deselectAllBtn.addEventListener('click', deselectAllRows);
        generateDocsBtn.addEventListener('click', generateSelectedDocuments);
        selectAllCheckbox.addEventListener('change', toggleAllCheckboxes);
        downloadTemplateBtn.addEventListener('click', downloadSampleTemplate);
        downloadExcelBtn.addEventListener('click', downloadSampleExcel);

        // Function to download sample template - now using direct file path
        function downloadSampleTemplate() {
            addLog('Downloading sample template...', 'info');
            
            // Download the template file directly from the specified path
            fetch(sampleTemplatePath)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.blob();
                })
                .then(blob => {
                    saveAs(blob, "RecommendationLetter_Template.docx");
                    addLog('Sample template downloaded successfully', 'success');
                })
                .catch(error => {
                    console.error('Error downloading template:', error);
                    addLog(`Error downloading template: ${error.message}`, 'error');
                    showStatus(`Error downloading template: ${error.message}`, 'error');
                });
        }

        // Function to download sample Excel data - now using direct file path
        function downloadSampleExcel() {
            addLog('Downloading sample Excel data...', 'info');
            
            // Download the Excel file directly from the specified path
            fetch(sampleExcelPath)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.blob();
                })
                .then(blob => {
                    saveAs(blob, "Applications-details.xlsx");
                    addLog('Sample Excel data downloaded successfully', 'success');
                })
                .catch(error => {
                    console.error('Error downloading Excel data:', error);
                    addLog(`Error downloading Excel data: ${error.message}`, 'error');
                    showStatus(`Error downloading Excel data: ${error.message}`, 'error');
                });
        }

        // Function to handle Word template upload
        async function handleWordTemplateUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            wordTemplateName.textContent = file.name;
            addLog(`Loading Word template: ${file.name}`, 'info');
            
            try {
                // Read the .docx file
                const arrayBuffer = await file.arrayBuffer();
                wordDocx = arrayBuffer; // Save for later use
                
                // Load the entire DOCX as a ZIP archive
                zipContent = new JSZip();
                await zipContent.loadAsync(arrayBuffer);
                
                // Get document.xml content
                const documentXml = await zipContent.file("word/document.xml").async("text");
                
                // Convert to HTML for preview using mammoth
                const result = await mammoth.convertToHtml({ arrayBuffer });
                wordContent = result.value;
                
                // Extract placeholders - look for [[placeholder]]
                addLog("Extracting placeholders from template...", 'info');
                
                // Use both the HTML content and XML for more reliable placeholder extraction
                extractPlaceholdersFromContent(documentXml);
                
                if (placeholders.length === 0) {
                    // If no placeholders found in XML, try from HTML
                    extractPlaceholdersFromContent(wordContent);
                }
                
                addLog(`Found ${placeholders.length} placeholders: ${Object.values(placeholderDisplayNames).join(', ')}`, 'info');
                
                // Show preview with highlighted placeholders
                let previewContent = wordContent;
                placeholders.forEach(placeholder => {
                    const displayName = placeholderDisplayNames[placeholder];
                    const regex = new RegExp(`\\[\\[${displayName}\\]\\]`, 'g');
                    previewContent = previewContent.replace(regex, `<span class="placeholder">[[${displayName}]]</span>`);
                });
                
                documentPreview.innerHTML = previewContent;
                
                // Create table headers
                createPlaceholderTable();
                
                // Enable buttons
                addRowBtn.disabled = false;
                selectAllBtn.disabled = false;
                deselectAllBtn.disabled = false;
                
                showStatus('Template loaded successfully. ' + placeholders.length + ' placeholders found.', 'success');
            } catch (error) {
                console.error('Error processing Word file:', error);
                addLog(`Error processing Word file: ${error.message}`, 'error');
                showStatus('Error processing Word file: ' + error.message, 'error');
            }
        }

        // Extract placeholders from content
        function extractPlaceholdersFromContent(content) {
            const placeholderRegex = /\[\[(.*?)\]\]/g;
            placeholders = [];
            placeholderDisplayNames = {};
            let match;
            
            while ((match = placeholderRegex.exec(content)) !== null) {
                const placeholder = match[1].trim();
                
                // Clean the placeholder for display (simplified display name)
                let displayName = placeholder;
                
                // Store both the original and display version
                if (!placeholders.includes(placeholder)) {
                    placeholders.push(placeholder);
                    placeholderDisplayNames[placeholder] = displayName;
                }
            }
        }

        // Function to handle Excel data upload
        async function handleExcelDataUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            excelDataName.textContent = file.name;
            addLog(`Loading Excel data: ${file.name}`, 'info');
            
            try {
                const data = await file.arrayBuffer();
                const workbook = XLSX.read(data, { type: 'array' });
                
                // Get first sheet or specific sheet name
                const sheetName = workbook.SheetNames[0];
                addLog(`Found sheet: ${sheetName}`, 'info');
                
                const sheet = workbook.Sheets[sheetName];
                
                // Convert to JSON
                excelData = XLSX.utils.sheet_to_json(sheet);
                
                if (excelData.length === 0) {
                    addLog('No data found in Excel file.', 'error');
                    showStatus('No data found in Excel file.', 'error');
                    return;
                }
                
                addLog(`Loaded ${excelData.length} rows of data`, 'success');
                
                // Check if we have placeholders extracted already
                if (placeholders.length === 0) {
                    addLog('Please upload a Word template first.', 'error');
                    showStatus('Please upload a Word template first.', 'error');
                    return;
                }
                
                // Map Excel columns to placeholders and populate table
                populateTableFromExcel();
                
                showStatus('Excel data loaded successfully. ' + excelData.length + ' rows found.', 'success');
                generateDocsBtn.disabled = false;
            } catch (error) {
                console.error('Error processing Excel file:', error);
                addLog(`Error processing Excel file: ${error.message}`, 'error');
                showStatus('Error processing Excel file: ' + error.message, 'error');
            }
        }

        // Function to create placeholder table headers
        function createPlaceholderTable() {
            const headerRow = placeholderTable.querySelector('thead tr');
            
            // Clear existing headers (except select and actions)
            while (headerRow.children.length > 2) {
                headerRow.removeChild(headerRow.lastChild);
            }
            
            // Add headers for each placeholder with clean display names
            placeholders.forEach(placeholder => {
                const th = document.createElement('th');
                th.textContent = placeholderDisplayNames[placeholder];
                headerRow.appendChild(th);
            });
            
            // Clear existing body rows
            const tbody = placeholderTable.querySelector('tbody');
            tbody.innerHTML = '';
            
            // Add an empty row
            addEmptyRow();
        }

        // Function to populate table from Excel data
        function populateTableFromExcel() {
            tableData = [];
            
            // Clear existing body rows
            const tbody = placeholderTable.querySelector('tbody');
            tbody.innerHTML = '';
            
            // For each Excel row, create a table row
            excelData.forEach((row, index) => {
                const rowData = {};
                
                // Map Excel columns to placeholders
                placeholders.forEach(placeholder => {
                    const displayName = placeholderDisplayNames[placeholder];
                    
                    // Try to find a matching column in the Excel data
                    if (row[displayName] !== undefined) {
                        rowData[placeholder] = row[displayName];
                    } else {
                        // Try case-insensitive match
                        const key = Object.keys(row).find(k => 
                            k.toLowerCase() === displayName.toLowerCase());
                        
                        if (key) {
                            rowData[placeholder] = row[key];
                        } else if (displayName === 'Date') {
                            // Special handling for Date placeholder
                            rowData[placeholder] = getCurrentFormattedDate();
                        } else {
                            rowData[placeholder] = '';
                        }
                    }
                });
                
                // Special handling for date if not found
                if (!rowData['Date'] && placeholders.includes('Date')) {
                    rowData['Date'] = getCurrentFormattedDate();
                }
                
                addLog(`Row ${index+1}: Mapped data for ID ${row.ID || index}`, 'info');
                tableData.push(rowData);
                addTableRow(rowData);
            });
        }

        // Helper to get current date in "%b %d, %Y" format (e.g., Apr 6, 2025)
        function getCurrentFormattedDate() {
            const date = new Date();
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
        }

        // Function to add an empty row to the table
        function addEmptyRow() {
            const emptyData = {};
            placeholders.forEach(placeholder => {
                const displayName = placeholderDisplayNames[placeholder];
                if (displayName === 'Date') {
                    // Special handling for Date placeholder
                    emptyData[placeholder] = getCurrentFormattedDate();
                } else {
                    emptyData[placeholder] = '';
                }
            });
            
            tableData.push(emptyData);
            addTableRow(emptyData);
        }

        // Function to add a row to the table with the given data
        function addTableRow(rowData) {
            const tbody = placeholderTable.querySelector('tbody');
            const tr = document.createElement('tr');
            
            // Checkbox cell
            const checkboxCell = document.createElement('td');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'row-checkbox';
            checkboxCell.appendChild(checkbox);
            tr.appendChild(checkboxCell);
            
            // Actions cell
            const actionsCell = document.createElement('td');
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'Delete';
            deleteBtn.className = 'btn btn-accent btn-sm';
            deleteBtn.addEventListener('click', () => {
                const index = Array.from(tbody.children).indexOf(tr);
                tableData.splice(index, 1);
                tbody.removeChild(tr);
            });
            actionsCell.appendChild(deleteBtn);
            tr.appendChild(actionsCell);
            
            // Data cells
            placeholders.forEach(placeholder => {
                const td = document.createElement('td');
                const textarea = document.createElement('textarea');
                textarea.value = rowData[placeholder] || '';
                textarea.addEventListener('input', (e) => {
                    const index = Array.from(tbody.children).indexOf(tr);
                    tableData[index][placeholder] = e.target.value;
                });
                
                // Make date fields special
                if (placeholderDisplayNames[placeholder] === 'Date') {
                    textarea.style.minHeight = '40px';  // Smaller height for date
                }
                
                td.appendChild(textarea);
                tr.appendChild(td);
            });
            
            tbody.appendChild(tr);
        }

        // Function to select all rows
        function selectAllRows() {
            document.querySelectorAll('.row-checkbox').forEach(checkbox => {
                checkbox.checked = true;
            });
            selectAllCheckbox.checked = true;
        }

        // Function to deselect all rows
        function deselectAllRows() {
            document.querySelectorAll('.row-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            selectAllCheckbox.checked = false;
        }

        // Function to toggle all checkboxes based on "Select All" checkbox
        function toggleAllCheckboxes() {
            const isChecked = selectAllCheckbox.checked;
            document.querySelectorAll('.row-checkbox').forEach(checkbox => {
                checkbox.checked = isChecked;
            });
        }

        // Function to generate documents for selected rows
        async function generateSelectedDocuments() {
            const checkboxes = document.querySelectorAll('.row-checkbox');
            const selectedIndices = [];
            
            checkboxes.forEach((checkbox, index) => {
                if (checkbox.checked) {
                    selectedIndices.push(index);
                }
            });
            
            if (selectedIndices.length === 0) {
                showStatus('Please select at least one row.', 'error');
                return;
            }
            
            addLog(`Generating documents for ${selectedIndices.length} selected rows...`, 'info');
            showStatus(`Generating ${selectedIndices.length} documents...`, 'success');
            
            // Show progress bar
            progressBarContainer.classList.remove('hidden');
            progressBar.style.width = '0%';
            
            // Show log container
            logContainer.classList.remove('hidden');
            
            try {
                // For each selected row
                for (let i = 0; i < selectedIndices.length; i++) {
                    const index = selectedIndices[i];
                    const rowData = tableData[index];
                    
                    // Update progress
                    const progress = Math.round((i / selectedIndices.length) * 100);
                    progressBar.style.width = progress + '%';
                    
                    // Generate a file identifier
                    let fileId = 'document_' + (index + 1);
                    if (rowData['ID']) {
                        fileId = rowData['ID'];
                    }
                    
                    addLog(`Processing row ${index + 1} (ID: ${fileId})...`, 'info');
                    
                    // Create and download Word document
                    const docxBlob = await createModifiedDocx(rowData, fileId);
                    saveAs(docxBlob, `${fileId}.docx`);
                    addLog(`Generated Word document: ${fileId}.docx`, 'success');
                    
                    // Create and download PDF - improved method
                    const pdfBlob = await createPDFFromDocx(docxBlob, fileId);
                    saveAs(pdfBlob, `${fileId}.pdf`);
                    addLog(`Generated PDF document: ${fileId}.pdf`, 'success');
                }
                
                // Complete progress bar
                progressBar.style.width = '100%';
                
                addLog(`Successfully generated ${selectedIndices.length} documents in both DOCX and PDF formats.`, 'success');
                showStatus(`Successfully generated ${selectedIndices.length} documents.`, 'success');
                
                // Hide progress bar after a delay
                setTimeout(() => {
                    progressBarContainer.classList.add('hidden');
                }, 3000);
                
            } catch (error) {
                console.error('Error generating documents:', error);
                addLog(`Error generating documents: ${error.message}`, 'error');
                showStatus('Error generating documents: ' + error.message, 'error');
                progressBarContainer.classList.add('hidden');
            }
        }

        // Function to create a modified docx with replaced placeholders
        async function createModifiedDocx(rowData, fileId) {
            try {
                // Check if we have the zipContent
                if (!zipContent) {
                    throw new Error("Template not loaded properly");
                }
                
                // Clone the zip to avoid modifying the original
                const newZip = new JSZip();
                
                // Copy all files from the original zip
                for (const filename of Object.keys(zipContent.files)) {
                    const file = zipContent.files[filename];
                    if (!file.dir) {
                        const content = await zipContent.file(filename).async('arraybuffer');
                        newZip.file(filename, content);
                    } else {
                        newZip.folder(filename);
                    }
                }
                
                // Get document.xml
                let documentXml = await newZip.file("word/document.xml").async("text");
                
                addLog(`Replacing placeholders in document for ${fileId}...`, 'info');
                
                // Replace placeholders in the XML
                placeholders.forEach(placeholder => {
                    const displayName = placeholderDisplayNames[placeholder];
                    let value = rowData[placeholder] || '';
                    
                    // Handle multiline text by replacing newlines with Word's line break
                    if (value.includes('\n')) {
                        // Need to handle XML structure correctly for line breaks
                        const safeValue = value
                            .replace(/&/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;')
                            .replace(/"/g, '&quot;')
                            .replace(/\n/g, '</w:t><w:br/><w:t>');
                            
                        // Replace the placeholder in the XML
                        const regex = new RegExp(`\\[\\[${displayName}\\]\\]`, 'g');
                        documentXml = documentXml.replace(regex, safeValue);
                    } else {
                        // Simple replacement for single-line text
                        const safeValue = value
                            .replace(/&/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;')
                            .replace(/"/g, '&quot;');
                            
                        const regex = new RegExp(`\\[\\[${displayName}\\]\\]`, 'g');
                        documentXml = documentXml.replace(regex, safeValue);
                    }
                });
                
                // Update the document.xml in the zip
                newZip.file("word/document.xml", documentXml);
                
                // Generate the modified docx
                const modifiedDocx = await newZip.generateAsync({ type: "blob", mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" });
                return modifiedDocx;
                
            } catch (error) {
                console.error('Error creating modified docx:', error);
                addLog(`Error creating modified document: ${error.message}`, 'error');
                throw error;
            }
        }

        // Improved PDF creation from DOCX using a more direct approach
        async function createPDFFromDocx(docxBlob, fileId) {
            // generat key from https://cloudconvert.com/dashboard/api/v2/keys
            const API_KEY = '';
            
            try {
                addLog(`Creating PDF for ${fileId} using CloudConvert...`, 'info');
                
                // Step 1: Create a job
                const createJobResponse = await fetch('https://api.cloudconvert.com/v2/jobs', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${API_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        "tasks": {
                            "upload-my-file": {
                                "operation": "import/upload"
                            },
                            "convert-my-file": {
                                "operation": "convert",
                                "input": "upload-my-file",
                                "output_format": "pdf",
                                "some_other_option": "value"
                            },
                            "export-my-file": {
                                "operation": "export/url",
                                "input": "convert-my-file"
                            }
                        }
                    })
                });

                if (!createJobResponse.ok) {
                    const errorText = await createJobResponse.text();
                    throw new Error(`Failed to create job: ${createJobResponse.status} ${createJobResponse.statusText} - ${errorText}`);
                }

                const jobData = await createJobResponse.json();
                const jobId = jobData.data.id;
                
                // Step 2: Upload the file to the provided upload URL
                const uploadTask = jobData.data.tasks.find(task => task.name === 'upload-my-file');
                const uploadUrl = uploadTask.result.form.url;
                const formData = new FormData();
                
                // Add all the form fields from the result
                Object.entries(uploadTask.result.form.parameters).forEach(([key, value]) => {
                    formData.append(key, value);
                });
                
                // Add the file
                formData.append('file', docxBlob, `${fileId}.docx`);
                
                const uploadResponse = await fetch(uploadUrl, {
                    method: 'POST',
                    body: formData
                });
                
                if (!uploadResponse.ok) {
                    throw new Error(`File upload failed: ${uploadResponse.status} ${uploadResponse.statusText}`);
                }
                
                addLog(`File uploaded successfully for ${fileId}, waiting for conversion...`, 'info');
                
                // Step 3: Wait for the job to complete and get the result directly
                const waitTime = 10000; // Wait 10 seconds for the conversion to complete
                await new Promise(resolve => setTimeout(resolve, waitTime));
                
                const jobStatusResponse = await fetch(`https://api.cloudconvert.com/v2/jobs/${jobId}`, {
                    headers: {
                        'Authorization': `Bearer ${API_KEY}`
                    }
                });
                
                if (!jobStatusResponse.ok) {
                    throw new Error(`Job status check failed: ${jobStatusResponse.status} ${jobStatusResponse.statusText}`);
                }
                
                const jobStatus = await jobStatusResponse.json();
                const exportTask = jobStatus.data.tasks.find(task => task.name === 'export-my-file');
                
                // Check if any task failed
                const failedTask = jobStatus.data.tasks.find(task => task.status === 'error');
                if (failedTask) {
                    throw new Error(`Conversion failed: ${failedTask.message || 'Unknown error'}`);
                }
                
                if (!exportTask || exportTask.status !== 'finished') {
                    throw new Error('Conversion not completed within the allocated time');
                }
                
                // Step 4: Download the converted file
                if (!exportTask.result || !exportTask.result.files || exportTask.result.files.length === 0) {
                    throw new Error('No output file found in the conversion result');
                }
                
                const downloadUrl = exportTask.result.files[0].url;
                const pdfResponse = await fetch(downloadUrl);
                
                if (!pdfResponse.ok) {
                    throw new Error(`PDF download failed: ${pdfResponse.status} ${pdfResponse.statusText}`);
                }
                
                const pdfBlob = await pdfResponse.blob();
                addLog(`PDF conversion successful for ${fileId}`, 'success');
                return pdfBlob;
                
            } catch (error) {
                addLog(`Server conversion failed, falling back to client-side method: ${error.message}`, 'warning');
                return enhancedDocxToPdfConversion(docxBlob, fileId);
            }
        }

        /**
         * Enhanced DOCX to PDF conversion with multiple fallback strategies
         * @param {Blob} docxBlob - The DOCX file as a Blob
         * @param {string} fileId - Identifier for the file being processed
         * @returns {Promise<Blob>} - PDF file as a Blob
         */
        async function enhancedDocxToPdfConversion(docxBlob, fileId) {
            try {
                addLog(`Starting PDF conversion for ${fileId}`, 'info');
                
                // Try MS Word automation first if available
                const msWordResult = await tryMicrosoftWordConversion(docxBlob, fileId);
                if (msWordResult) return msWordResult;
                
                // Try PDF.js + PSPDFKit approach
                const pdfLibResult = await tryPdfLibraryConversion(docxBlob, fileId);
                if (pdfLibResult) return pdfLibResult;
                
                // Finally fall back to the iframe + html2canvas approach
                return await iframeHtmlCanvasConversion(docxBlob, fileId);
            } catch (error) {
                console.error('All PDF conversion methods failed:', error);
                addLog(`Critical error in PDF conversion: ${error.message}`, 'error');
                throw new Error(`PDF conversion failed for ${fileId}: ${error.message}`);
            }
        }

        /**
         * Try to use installed Microsoft Word via ActiveX (Windows) or AppleScript (Mac)
         */
        async function tryMicrosoftWordConversion(docxBlob, fileId) {
            try {
                addLog(`Attempting MS Word conversion for ${fileId}`, 'info');
                
                // Check if we're in a compatible environment
                const isWindows = navigator.userAgent.indexOf('Windows') !== -1;
                const isMac = navigator.userAgent.indexOf('Mac') !== -1;
                
                if (!isWindows && !isMac) {
                    addLog('MS Word conversion only available on Windows/Mac', 'info');
                    return null;
                }

                // For Windows using ActiveX
                if (isWindows && window.ActiveXObject !== undefined) {
                    // Save temp file using the File System Access API
                    try {
                        // Create a temp file handler
                        const tempDocxHandle = await window.showSaveFilePicker({
                            suggestedName: `${fileId}_temp.docx`,
                            types: [{
                                description: 'Word Document',
                                accept: {'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx']}
                            }],
                            excludeAcceptAllOption: true
                        });
                        
                        // Write the docx blob to the file
                        const writableStream = await tempDocxHandle.createWritable();
                        await writableStream.write(docxBlob);
                        await writableStream.close();
                        
                        // Create temp PDF file handler
                        const tempPdfHandle = await window.showSaveFilePicker({
                            suggestedName: `${fileId}.pdf`,
                            types: [{
                                description: 'PDF Document',
                                accept: {'application/pdf': ['.pdf']}
                            }],
                            excludeAcceptAllOption: true
                        });
                        
                        // Use ActiveX to open Word and export as PDF
                        const wordApp = new ActiveXObject("Word.Application");
                        wordApp.Visible = false;
                        
                        const docPath = await tempDocxHandle.getFile().then(file => file.path);
                        const pdfPath = await tempPdfHandle.getFile().then(file => file.path);
                        
                        const doc = wordApp.Documents.Open(docPath);
                        doc.ExportAsFixedFormat(pdfPath, 17); // 17 = PDF format
                        doc.Close();
                        wordApp.Quit();
                        
                        // Read the PDF back
                        const pdfFile = await tempPdfHandle.getFile();
                        const pdfBlob = await pdfFile.arrayBuffer().then(buffer => new Blob([buffer], {type: 'application/pdf'}));
                        
                        addLog(`MS Word conversion successful for ${fileId}`, 'success');
                        return pdfBlob;
                    } catch (fsaError) {
                        console.error('File System Access API error:', fsaError);
                        addLog('MS Word conversion failed: File System Access issue', 'warning');
                        return null;
                    }
                }
                
                // For Mac using browser extension or native messaging
                if (isMac) {
                    // Check if our helper extension is installed
                    if (window.macOSWordHelper) {
                        const result = await window.macOSWordHelper.convertDocxToPdf({
                            docxData: await docxBlob.arrayBuffer(),
                            filename: fileId
                        });
                        
                        if (result && result.success) {
                            addLog(`Mac Word conversion successful for ${fileId}`, 'success');
                            return new Blob([result.pdfData], {type: 'application/pdf'});
                        }
                    }
                }
                
                addLog('MS Word not available or conversion failed', 'info');
                return null;
            } catch (error) {
                console.error('MS Word conversion error:', error);
                addLog(`MS Word conversion failed: ${error.message}`, 'warning');
                return null;
            }
        }

        /**
         * Try conversion using PDF libraries (pdf-lib, jspdf, pdfmake)
         */
        async function tryPdfLibraryConversion(docxBlob, fileId) {
            try {
                addLog(`Attempting PDF library conversion for ${fileId}`, 'info');
                
                // Convert DOCX to HTML with enhanced options
                const mammothResult = await mammoth.convertToHtml(
                    { arrayBuffer: await docxBlob.arrayBuffer() },
                    { 
                        preserveStyles: true,
                        includeEmbeddedStyleMap: true,
                        includeDefaultStyleMap: true,
                        styleMap: [
                            "p[style-name='Title'] => h1.title:fresh",
                            "p[style-name='Heading 1'] => h1:fresh",
                            "p[style-name='Heading 2'] => h2:fresh",
                            "p[style-name='Heading 3'] => h3:fresh",
                            "p[style-name='Normal'] => p:fresh",
                            "table => table.docx-table:fresh",
                            "r[style-name='Strong'] => strong:fresh"
                        ],
                        convertImage: mammoth.images.imgElement(function(image) {
                            return image.read("base64").then(function(imageBuffer) {
                                return {
                                    src: "data:" + image.contentType + ";base64," + imageBuffer,
                                    class: "docx-image",
                                    alt: image.altText || "",
                                    style: `max-width: 100%; ${image.altText || ""}`
                                };
                            });
                        })
                    }
                );
                
                // If PDFMake is available, use it for better layout control
                if (window.pdfMake) {
                    // Create a temporary DOM parser to work with the HTML
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(mammothResult.value, 'text/html');
                    
                    // Extract content and format for pdfmake
                    const content = [];
                    const styles = {};
                    
                    // Process headings, paragraphs, tables, etc.
                    Array.from(doc.body.children).forEach(element => {
                        switch(element.tagName.toLowerCase()) {
                            case 'h1':
                                content.push({ text: element.textContent, style: 'heading1', margin: [0, 20, 0, 10] });
                                break;
                            case 'h2':
                                content.push({ text: element.textContent, style: 'heading2', margin: [0, 15, 0, 10] });
                                break;
                            case 'h3':
                                content.push({ text: element.textContent, style: 'heading3', margin: [0, 10, 0, 5] });
                                break;
                            case 'p':
                                // Check for inline styles or elements
                                if (element.innerHTML.includes('<')) {
                                    // Complex paragraph with formatting
                                    const inlineContent = processInlineElements(element);
                                    content.push({ text: inlineContent, margin: [0, 0, 0, 10] });
                                } else {
                                    // Simple paragraph
                                    content.push({ text: element.textContent, margin: [0, 0, 0, 10] });
                                }
                                break;
                            case 'table':
                                const tableData = [];
                                Array.from(element.querySelectorAll('tr')).forEach(row => {
                                    const rowData = [];
                                    Array.from(row.querySelectorAll('td, th')).forEach(cell => {
                                        rowData.push(cell.textContent.trim());
                                    });
                                    tableData.push(rowData);
                                });
                                
                                content.push({
                                    table: {
                                        headerRows: element.querySelector('th') ? 1 : 0,
                                        widths: Array(tableData[0].length).fill('*'),
                                        body: tableData
                                    },
                                    margin: [0, 5, 0, 15]
                                });
                                break;
                            case 'img':
                                content.push({
                                    image: element.src,
                                    width: Math.min(element.width || 400, 500),
                                    margin: [0, 5, 0, 5]
                                });
                                break;
                            case 'ul':
                            case 'ol':
                                const listItems = [];
                                Array.from(element.querySelectorAll('li')).forEach(item => {
                                    listItems.push(item.textContent.trim());
                                });
                                
                                content.push({
                                    [element.tagName.toLowerCase() === 'ul' ? 'ul' : 'ol']: listItems,
                                    margin: [0, 5, 0, 15]
                                });
                                break;
                        }
                    });
                    
                    // Helper function to process inline elements
                    function processInlineElements(element) {
                        const result = [];
                        Array.from(element.childNodes).forEach(node => {
                            if (node.nodeType === Node.TEXT_NODE) {
                                result.push(node.textContent);
                            } else if (node.nodeType === Node.ELEMENT_NODE) {
                                switch(node.tagName.toLowerCase()) {
                                    case 'strong':
                                    case 'b':
                                        result.push({ text: node.textContent, bold: true });
                                        break;
                                    case 'em':
                                    case 'i':
                                        result.push({ text: node.textContent, italics: true });
                                        break;
                                    case 'u':
                                        result.push({ text: node.textContent, decoration: 'underline' });
                                        break;
                                    case 'a':
                                        result.push({ text: node.textContent, link: node.href, color: 'blue' });
                                        break;
                                    default:
                                        result.push(node.textContent);
                                }
                            }
                        });
                        return result;
                    }
                    
                    // Set up the document definition
                    const docDefinition = {
                        content: content,
                        styles: {
                            heading1: {
                                fontSize: 18,
                                bold: true,
                            },
                            heading2: {
                                fontSize: 16,
                                bold: true,
                            },
                            heading3: {
                                fontSize: 14,
                                bold: true,
                            }
                        },
                        defaultStyle: {
                            fontSize: 12,
                            font: 'Times'
                        },
                        pageSize: 'LETTER',
                        pageMargins: [40, 60, 40, 60]
                    };
                    
                    // Generate PDF
                    const pdfDocGenerator = pdfMake.createPdf(docDefinition);
                    return new Promise((resolve, reject) => {
                        pdfDocGenerator.getBlob((blob) => {
                            addLog(`PDF library conversion successful for ${fileId}`, 'success');
                            resolve(blob);
                        });
                    });
                }
                
                // If no PDF generation libs available
                return null;
            } catch (error) {
                console.error('PDF library conversion error:', error);
                addLog(`PDF library conversion failed: ${error.message}`, 'warning');
                return null;
            }
        }

        /**
         * Fall back to iframe + html2canvas approach (improved version)
         */
        async function iframeHtmlCanvasConversion(docxBlob, fileId) {
            try {
                addLog(`Creating PDF for ${fileId} using client-side HTML rendering...`, 'info');
                
                // Create a temporary iframe with proper dimensions for a letter page
                const iframe = document.createElement('iframe');
                iframe.style.width = '8.5in';
                iframe.style.height = '11in';
                iframe.style.position = 'fixed';
                iframe.style.left = '-9999px';
                iframe.style.border = 'none';
                iframe.style.overflow = 'hidden';
                document.body.appendChild(iframe);
                
                // Convert DOCX to HTML with enhanced options
                const result = await mammoth.convertToHtml(
                    { arrayBuffer: await docxBlob.arrayBuffer() },
                    { 
                        preserveStyles: true,
                        includeEmbeddedStyleMap: true,
                        includeDefaultStyleMap: true,
                        styleMap: [
                            "p[style-name='Title'] => h1.title:fresh",
                            "p[style-name='Heading 1'] => h1:fresh",
                            "p[style-name='Heading 2'] => h2:fresh",
                            "p[style-name='Heading 3'] => h3:fresh",
                            "p[style-name='Normal'] => p:fresh",
                            "table => table.docx-table:fresh",
                            "r[style-name='Strong'] => strong:fresh"
                        ],
                        convertImage: mammoth.images.imgElement(function(image) {
                            return image.read("base64").then(function(imageBuffer) {
                                return {
                                    src: "data:" + image.contentType + ";base64," + imageBuffer,
                                    class: "docx-image",
                                    alt: image.altText || "",
                                    style: `max-width: 100%; ${image.altText || ""}`
                                };
                            });
                        })
                    }
                );
                
                // More comprehensive Word-like CSS
                const enhancedCSS = `
                    @page {
                        size: 8.5in 11in;
                        margin: 1in;
                    }
                    body {
                        font-family: 'Times New Roman', serif;
                        font-size: 12pt;
                        line-height: 1.5;
                        color: black;
                        margin: 0;
                        padding: 1in;
                        box-sizing: border-box;
                        counter-reset: page;
                    }
                    /* Images */
                    .docx-image {
                        max-width: 100%;
                        height: auto;
                        display: block;
                        margin: 10pt auto;
                    }
                    /* Tables */
                    .docx-table {
                        border-collapse: collapse;
                        width: 100%;
                        margin: 12pt 0;
                    }
                    .docx-table td, .docx-table th {
                        border: 1px solid #ddd;
                        padding: 8px;
                        text-align: left;
                    }
                    .docx-table th {
                        background-color: #f2f2f2;
                        font-weight: bold;
                    }
                    /* Typography */
                    p {
                        margin: 0 0 10pt 0;
                        text-align: left;
                        orphans: 2;
                        widows: 2;
                    }
                    h1, h2, h3, h4, h5, h6 {
                        font-weight: bold;
                        page-break-after: avoid;
                    }
                    h1 {
                        font-size: 16pt;
                        margin: 24pt 0 12pt 0;
                    }
                    h2 {
                        font-size: 14pt;
                        margin: 18pt 0 6pt 0;
                    }
                    h3 {
                        font-size: 13pt;
                        margin: 14pt 0 6pt 0;
                    }
                    h1.title {
                        font-size: 18pt;
                        text-align: center;
                        margin: 24pt 0 24pt 0;
                    }
                    /* Lists */
                    ul, ol {
                        margin: 12pt 0;
                        padding-left: 40px;
                    }
                    li {
                        margin-bottom: 6pt;
                    }
                    /* Hyperlinks */
                    a {
                        color: blue;
                        text-decoration: underline;
                    }
                    /* Page break control */
                    .page-break {
                        page-break-after: always;
                        height: 0;
                        display: block;
                    }
                `;
                
                // Add the enhanced HTML content to the iframe
                iframe.contentDocument.open();
                iframe.contentDocument.write(`
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <meta charset="utf-8">
                        <title>${fileId}</title>
                        <style>${enhancedCSS}</style>
                    </head>
                    <body>${result.value}</body>
                    </html>
                `);
                iframe.contentDocument.close();
                
                // Wait for all content and images to load with a better promise implementation
                await new Promise((resolve, reject) => {
                    let checkCount = 0;
                    const maxChecks = 50; // 5 seconds max wait time
                    
                    const checkReady = () => {
                        checkCount++;
                        const images = iframe.contentDocument.querySelectorAll('img');
                        let allLoaded = true;
                        
                        for (const img of images) {
                            if (!img.complete) {
                                allLoaded = false;
                                break;
                            }
                        }
                        
                        if (allLoaded && iframe.contentDocument.readyState === 'complete') {
                            resolve();
                        } else if (checkCount > maxChecks) {
                            addLog(`Warning: Some images may not have loaded for ${fileId}`, 'warning');
                            resolve();
                        } else {
                            setTimeout(checkReady, 100);
                        }
                    };
                    
                    iframe.onload = checkReady;
                    setTimeout(checkReady, 100);
                });
                
                // Implement better multi-page detection and rendering
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'pt',
                    format: 'letter'
                });
                
                // Get page dimensions in points
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                
                // Improved approach: use multiple canvases for each page to avoid memory issues
                // Find natural page breaks or calculate based on content height
                const body = iframe.contentDocument.body;
                const contentHeight = body.scrollHeight;
                const contentWidth = body.scrollWidth;
                
                // Calculate scaling factor
                const scale = Math.min(pageWidth / contentWidth, 1);
                
                // Approximate number of pages needed
                const pagesNeeded = Math.ceil(contentHeight / (pageHeight / scale));
                
                addLog(`Rendering ${pagesNeeded} page(s) for ${fileId}...`, 'info');
                
                // Render each page individually
                for (let pageNum = 0; pageNum < pagesNeeded; pageNum++) {
                    if (pageNum > 0) {
                        pdf.addPage();
                    }
                    
                    // Set the scroll position for this page segment
                    const scrollTop = (pageHeight / scale) * pageNum;
                    iframe.contentWindow.scrollTo(0, scrollTop);
                    
                    // Create a canvas for just this visible portion
                    const canvas = await html2canvas(body, {
                        scale: 2, // Higher resolution
                        useCORS: true,
                        allowTaint: true,
                        letterRendering: true,
                        logging: false,
                        windowWidth: contentWidth,
                        windowHeight: pageHeight / scale,
                        x: 0,
                        y: scrollTop,
                        width: contentWidth,
                        height: Math.min(pageHeight / scale, contentHeight - scrollTop),
                        backgroundColor: '#ffffff'
                    });
                    
                    // Add this canvas segment to the PDF
                    pdf.addImage(
                        canvas.toDataURL('image/jpeg', 0.95),
                        'JPEG',
                        0, 0,
                        pageWidth, pageHeight,
                        null,
                        'FAST'
                    );
                    
                    // Free memory by removing the canvas reference
                    canvas.remove();
                }
                
                // Clean up
                document.body.removeChild(iframe);
                
                // Return the PDF blob
                const pdfBlob = pdf.output('blob');
                addLog(`PDF creation completed for ${fileId}`, 'success');
                return pdfBlob;
                
            } catch (error) {
                console.error('Error in iframe PDF creation:', error);
                addLog(`Error in iframe PDF creation: ${error.message}`, 'error');
                throw error;
            }
        }

        


        // Function to show status message
        function showStatus(message, type) {
            statusMessage.textContent = message;
            statusMessage.className = 'status-message ' + type;
            statusMessage.classList.remove('hidden');
            
            // Hide after 5 seconds for success messages
            if (type === 'success') {
                setTimeout(() => {
                    statusMessage.classList.add('hidden');
                }, 5000);
            }
        }

        // Function to add log entry
        function addLog(message, type) {
            logContainer.classList.remove('hidden');
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            logEntries.appendChild(logEntry);
            logEntries.scrollTop = logEntries.scrollHeight;
        }
    </script>
</body>
</html>