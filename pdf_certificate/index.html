<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Certificate Generator</title>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #e9f0f9;
            --accent-color: #ff6b6b;
            --text-color: #333;
            --light-gray: #f5f5f5;
            --border-color: #ddd;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            color: var(--text-color);
            line-height: 1.6;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #f8f9fa;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 20px;
            text-align: center;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        @media (min-width: 768px) {
            .container {
                grid-template-columns: minmax(300px, 30%) 1fr;
            }
        }

        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .files-section, .search-section, .sample-files-section {
            margin-bottom: 25px;
        }

        h2 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--primary-color);
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 5px;
        }

        .file-input-container {
            position: relative;
            margin-bottom: 15px;
        }

        .custom-file-upload {
            display: block;
            width: 100%;
            padding: 10px 15px;
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        .custom-file-upload:hover {
            background-color: #3b5a8c;
        }

        .preview-section {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        .certificate-preview {
            margin-top: 15px;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: white;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .certificate-preview img {
            max-width: 100%;
            max-height: 400px;
            object-fit: contain;
        }

        .placeholder {
            background-color: var(--secondary-color);
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .table-container {
            overflow-x: auto;
            margin-top: 20px;
            max-width: 100%;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            min-width: 650px;
        }

        th, td {
            padding: 10px;
            border: 1px solid var(--border-color);
            text-align: left;
            vertical-align: top;
        }

        th {
            background-color: var(--secondary-color);
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .table-actions {
            margin-top: 15px;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .btn:hover {
            background-color: #3b5a8c;
        }

        .btn-accent {
            background-color: var(--accent-color);
        }

        .btn-accent:hover {
            background-color: #e05151;
        }

        .btn-sm {
            padding: 5px 10px;
            font-size: 0.85rem;
        }

        .file-name {
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }

        .checkbox-container {
            margin-right: 10px;
        }

        input[type="text"], input[type="date"] {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .status-message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
        }

        .success {
            background-color: #d4edda;
            color: #155724;
        }

        .error {
            background-color: #f8d7da;
            color: #721c24;
        }

        .warning {
            background-color: #fff3cd;
            color: #856404;
        }

        .hidden {
            display: none;
        }

        .progress-bar-container {
            width: 100%;
            height: 20px;
            background-color: var(--light-gray);
            border-radius: 10px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            width: 0%;
            transition: width 0.3s;
        }

        .log-container {
            margin-top: 15px;
            padding: 10px;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }

        .log-entry {
            margin-bottom: 3px;
        }

        .log-info {
            color: #0077cc;
        }

        .log-success {
            color: #28a745;
        }

        .log-error {
            color: #dc3545;
        }

        .sample-files-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .sample-btn {
            font-size: 0.85rem;
            flex: 1;
            min-width: 120px;
        }
    </style>
</head>
<body>
    <h1>Certificate Generator</h1>
    
    <div class="container">
        <div class="controls">
            <div class="sample-files-section">
                <h2>Sample Files</h2>
                <div class="sample-files-buttons">
                    <button id="downloadTemplateBtn" class="btn sample-btn">Download Template</button>
                    <button id="downloadExcelBtn" class="btn sample-btn">Download Data Sample</button>
                </div>
            </div>
            
            <div class="files-section">
                <h2>Upload Files</h2>
                <div class="file-input-container">
                    <label for="pptxTemplate" class="custom-file-upload">
                        Upload Certificate Template (.pptx)
                    </label>
                    <input type="file" id="pptxTemplate" accept=".pptx" style="display: none;">
                    <div id="pptxTemplateName" class="file-name"></div>
                </div>
                
                <div class="file-input-container">
                    <label for="excelData" class="custom-file-upload">
                        Upload Recipient Data (.xlsx, .csv)
                    </label>
                    <input type="file" id="excelData" accept=".xlsx,.csv" style="display: none;">
                    <div id="excelDataName" class="file-name"></div>
                </div>
            </div>
            
            <div class="options-section">
                <h2>Actions</h2>
                <button id="addRowBtn" class="btn" disabled>Add Row</button>
                <button id="selectAllBtn" class="btn" disabled>Select All</button>
                <button id="deselectAllBtn" class="btn" disabled>Deselect All</button>
                <button id="generateCertsBtn" class="btn btn-accent" disabled>Generate Selected Certificates</button>
                <div id="progressBarContainer" class="progress-bar-container hidden">
                    <div id="progressBar" class="progress-bar"></div>
                </div>
            </div>
            
            <div id="statusMessage" class="status-message hidden"></div>
            
            <div id="logContainer" class="log-container hidden">
                <div id="logEntries"></div>
            </div>
        </div>
        
        <div class="preview-section">
            <h2>Template Preview</h2>
            <div id="certificatePreview" class="certificate-preview">
                <p>Upload a PowerPoint template to see preview here.</p>
            </div>
            
            <h2>Recipient Data</h2>
            <div class="table-container">
                <table id="recipientTable">
                    <thead>
                        <tr>
                            <th><input type="checkbox" id="selectAllCheckbox"></th>
                            <th>Actions</th>
                            <th>ID</th>
                            <th>Name</th>
                            <th>Award</th>
                            <th>Sponsor</th>
                            <th>Date</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Table rows will be added dynamically -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/build/pdf.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

    <script>
        // Global variables
        // Replace the static PLACEHOLDERS constant with a dynamic object that will be populated based on template analysis
        let PLACEHOLDERS = {};
        
        let pptxFile = null;
        let pptxZip = null;
        let excelData = [];
        let tableData = [];
        
        // Sample file paths
        const sampleTemplatePath = "Certificate_Template.pptx";
        const sampleExcelPath = "Recipients.xlsx";

        // DOM elements
        const pptxTemplateInput = document.getElementById('pptxTemplate');
        const pptxTemplateName = document.getElementById('pptxTemplateName');
        const excelDataInput = document.getElementById('excelData');
        const excelDataName = document.getElementById('excelDataName');
        const certificatePreview = document.getElementById('certificatePreview');
        const recipientTable = document.getElementById('recipientTable');
        const addRowBtn = document.getElementById('addRowBtn');
        const selectAllBtn = document.getElementById('selectAllBtn');
        const deselectAllBtn = document.getElementById('deselectAllBtn');
        const generateCertsBtn = document.getElementById('generateCertsBtn');
        const statusMessage = document.getElementById('statusMessage');
        const selectAllCheckbox = document.getElementById('selectAllCheckbox');
        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressBar = document.getElementById('progressBar');
        const logContainer = document.getElementById('logContainer');
        const logEntries = document.getElementById('logEntries');
        const downloadTemplateBtn = document.getElementById('downloadTemplateBtn');
        const downloadExcelBtn = document.getElementById('downloadExcelBtn');

        // Event listeners
        pptxTemplateInput.addEventListener('change', handlePPTXTemplateUpload);
        excelDataInput.addEventListener('change', handleExcelDataUpload);
        addRowBtn.addEventListener('click', addEmptyRow);
        selectAllBtn.addEventListener('click', selectAllRows);
        deselectAllBtn.addEventListener('click', deselectAllRows);
        generateCertsBtn.addEventListener('click', generateSelectedCertificates);
        selectAllCheckbox.addEventListener('change', toggleAllCheckboxes);
        downloadTemplateBtn.addEventListener('click', downloadSampleTemplate);
        downloadExcelBtn.addEventListener('click', downloadSampleExcel);

        // Function to download sample template
        function downloadSampleTemplate() {
            addLog('Downloading sample certificate template...', 'info');
            
            fetch(sampleTemplatePath)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.blob();
                })
                .then(blob => {
                    saveAs(blob, "Certificate_Template.pptx");
                    addLog('Sample template downloaded successfully', 'success');
                })
                .catch(error => {
                    console.error('Error downloading template:', error);
                    addLog(`Error downloading template: ${error.message}`, 'error');
                    showStatus(`Error downloading template: ${error.message}`, 'error');
                });
        }

        // Function to download sample Excel data
        function downloadSampleExcel() {
            addLog('Downloading sample recipient data...', 'info');
            
            fetch(sampleExcelPath)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.blob();
                })
                .then(blob => {
                    saveAs(blob, "Recipients.xlsx");
                    addLog('Sample data downloaded successfully', 'success');
                })
                .catch(error => {
                    console.error('Error downloading data:', error);
                    addLog(`Error downloading data: ${error.message}`, 'error');
                    showStatus(`Error downloading data: ${error.message}`, 'error');
                });
        }

        // Function to handle PPTX template upload
        async function handlePPTXTemplateUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            pptxTemplateName.textContent = file.name;
            addLog(`Loading PPTX template: ${file.name}`, 'info');
            
            try {
                // Read the .pptx file
                const arrayBuffer = await file.arrayBuffer();
                pptxFile = arrayBuffer;
                
                // Load the PPTX as a ZIP archive
                pptxZip = new JSZip();
                await pptxZip.loadAsync(arrayBuffer);
                
                // Extract placeholders by examining slide XML content
                await extractPlaceholdersFromPPTX();
                
                // Create preview image
                await createPPTXPreview();
                
                // Enable buttons
                addRowBtn.disabled = false;
                selectAllBtn.disabled = false;
                deselectAllBtn.disabled = false;
                
                showStatus('Template loaded successfully.', 'success');
            } catch (error) {
                console.error('Error processing PPTX file:', error);
                addLog(`Error processing PPTX file: ${error.message}`, 'error');
                showStatus('Error processing PPTX file: ' + error.message, 'error');
            }
        }

        // Extract placeholders from PPTX content
        async function extractPlaceholdersFromPPTX() {
            try {
                addLog("Analyzing PPTX to find placeholders...", 'info');
                
                // Get slide XML files
                const slideFiles = [];
                for (const filename of Object.keys(pptxZip.files)) {
                    if (filename.startsWith('ppt/slides/slide') && filename.endsWith('.xml')) {
                        slideFiles.push(filename);
                    }
                }
                
                addLog(`Found ${slideFiles.length} slides in the template`, 'info');
                
                // Check each slide for placeholders
                const detectedPlaceholders = {};
                
                for (const slideFile of slideFiles) {
                    const slideXml = await pptxZip.file(slideFile).async("text");
                    
                    // Check for [[placeholder]] format
                    const placeholderRegex = /\[\[(.*?)\]\]/g;
                    let match;
                    while ((match = placeholderRegex.exec(slideXml)) !== null) {
                        const placeholder = match[1].trim();
                        detectedPlaceholders[placeholder] = placeholder;
                        addLog(`Found placeholder: [[${placeholder}]]`, 'info');
                    }
                }
                
                if (Object.keys(detectedPlaceholders).length > 0) {
                    // Update global PLACEHOLDERS object with the detected placeholders
                    PLACEHOLDERS = detectedPlaceholders;
                    addLog(`Detected ${Object.keys(PLACEHOLDERS).length} unique placeholders in template`, 'success');
                    
                    // Rebuild the table headers and data to include detected placeholders
                    rebuildTableWithPlaceholders();
                } else {
                    addLog("No placeholders found in the format [[placeholder]]", 'warning');
                    addLog("Please add placeholders to your template using the format [[placeholder]]", 'info');
                    // Create an empty table with just ID column
                    PLACEHOLDERS = {};
                    rebuildTableWithPlaceholders();
                }
            } catch (error) {
                console.error('Error extracting placeholders:', error);
                addLog(`Error extracting placeholders: ${error.message}`, 'error');
            }
        }

        // Function to rebuild the table with detected placeholders
        function rebuildTableWithPlaceholders() {
            // Preserve existing data
            const existingData = [...tableData];
            
            // Rebuild the table header
            const thead = recipientTable.querySelector('thead');
            const headerRow = thead.querySelector('tr');
            
            // Keep the first two columns (checkbox and actions)
            while (headerRow.children.length > 2) {
                headerRow.removeChild(headerRow.lastChild);
            }
            
            // Add ID column
            const idTh = document.createElement('th');
            idTh.textContent = 'ID';
            headerRow.appendChild(idTh);
            
            // Add columns for each placeholder
            for (const placeholder in PLACEHOLDERS) {
                const th = document.createElement('th');
                th.textContent = placeholder;
                headerRow.appendChild(th);
            }
            
            // Clear the table body
            const tbody = recipientTable.querySelector('tbody');
            tbody.innerHTML = '';
            
            // If we have existing data, update it to include all placeholders
            if (existingData.length > 0) {
                tableData = existingData.map(row => {
                    const newRow = { ID: row.ID };
                    // Preserve existing data for placeholders that match
                    for (const placeholder in PLACEHOLDERS) {
                        newRow[placeholder] = row[placeholder] || '';
                    }
                    return newRow;
                });
            } else {
                tableData = [];
            }
            
            // Re-add the rows with updated data structure
            tableData.forEach(rowData => {
                addTableRow(rowData);
            });
            
            // If no rows, add an empty one
            if (tableData.length === 0) {
                addEmptyRow();
            }
            
            // Enable buttons if we have placeholders
            if (Object.keys(PLACEHOLDERS).length > 0) {
                addRowBtn.disabled = false;
                selectAllBtn.disabled = false;
                deselectAllBtn.disabled = false;
            }
            
            addLog(`Table updated with ${Object.keys(PLACEHOLDERS).length} placeholder columns`, 'success');
        }


        // Create a preview image from the first slide
        async function createPPTXPreview() {
            try {
                certificatePreview.innerHTML = '<p>Generating preview...</p>';
                addLog("Generating PPTX preview...", 'info');
                
                // First check if there are any image files that might represent the slide
                const mediaFiles = Object.keys(pptxZip.files).filter(filename => 
                    filename.startsWith('ppt/media/'));
                
                // Get slide XML files to extract text and placeholders
                const slideFiles = Object.keys(pptxZip.files).filter(filename => 
                    filename.startsWith('ppt/slides/slide') && filename.endsWith('.xml'));
                
                if (slideFiles.length === 0) {
                    throw new Error("No slides found in the template");
                }
                
                // Get the first slide's XML content
                const firstSlideXml = await pptxZip.file(slideFiles[0]).async("text");
                
                // Extract text and placeholders from the XML
                const extractedContent = extractContentFromSlideXml(firstSlideXml);
                
                // Check if we found any background or large image that could be used for preview
                const backgroundImage = await findLargestImage(mediaFiles);
                
                if (backgroundImage) {
                    // If we found a usable image, display it with placeholders overlaid
                    certificatePreview.innerHTML = `
                        <div style="position: relative; width: 100%; height: 300px; display: flex; justify-content: center; align-items: center; overflow: hidden;">
                            <img src="${backgroundImage}" style="max-width: 100%; max-height: 100%; object-fit: contain;" alt="Certificate Background">
                            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; padding: 20px; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; background-color: rgba(255, 255, 255, 0.7);">
                                ${extractedContent.placeholdersHtml}
                            </div>
                        </div>
                    `;
                    addLog("Generated image-based preview with placeholders", 'success');
                } else {
                    // Create a text-based representation
                    certificatePreview.innerHTML = `
                        <div style="width: 100%; height: 300px; background-color: #f9f9f9; border: 1px solid #ddd; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 20px;">
                            <h2 style="color: #444; margin-bottom: 20px;">Certificate Template</h2>
                            ${extractedContent.placeholdersHtml || extractedContent.textHtml || getDefaultPlaceholdersHtml()}
                            <p style="font-style: italic; margin-top: 20px; color: #666;">Note: This is a simplified preview. The actual certificate will include all formatting and images.</p>
                        </div>
                    `;
                    addLog("Generated text-based preview with placeholders", 'info');
                }
                
                // Add information about found placeholders
                if (extractedContent.foundPlaceholders.length > 0) {
                    addLog(`Found placeholders in template: ${extractedContent.foundPlaceholders.join(', ')}`, 'info');
                } else {
                    addLog("No placeholders found in template. Using default placeholders.", 'warning');
                }
                
            } catch (error) {
                console.error('Error creating preview:', error);
                addLog(`Error creating preview: ${error.message}`, 'error');
                certificatePreview.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <p>Could not generate preview. The PPTX file might be in an unsupported format.</p>
                        <p style="margin-top: 10px;">You can still use this template to generate certificates.</p>
                    </div>
                `;
            }
        }

        // Find the largest image in the PPTX that might be usable as a preview
        async function findLargestImage(mediaFiles) {
            try {
                let largestImage = null;
                let largestSize = 0;
                
                // Look for image files that might be a slide background or large enough to be meaningful
                for (const mediaFile of mediaFiles) {
                    const file = pptxZip.files[mediaFile];
                    if (file && !file.dir) {
                        const fileData = await pptxZip.file(mediaFile).async("blob");
                        
                        // Only consider files larger than 5KB to avoid tiny images
                        if (fileData.size > 5 * 1024 && fileData.size > largestSize) {
                            largestSize = fileData.size;
                            largestImage = URL.createObjectURL(fileData);
                        }
                    }
                }
                
                return largestImage;
            } catch (error) {
                console.error('Error finding preview image:', error);
                return null;
            }
        }

        // Extract content from slide XML
        function extractContentFromSlideXml(slideXml) {
            const result = {
                textHtml: '',
                placeholdersHtml: '',
                foundPlaceholders: []
            };
            
            try {
                // Extract text content
                const textElements = [];
                const textRegex = /<a:t[^>]*>([\s\S]*?)<\/a:t>/g;
                let textMatch;
                
                while ((textMatch = textRegex.exec(slideXml)) !== null) {
                    const text = textMatch[1].trim();
                    if (text) {
                        textElements.push(text);
                    }
                }
                
                // Build HTML from text content
                let textHtml = '';
                let placeholdersHtml = '';
                
                for (const text of textElements) {
                    const placeholderRegex = /\[\[(.*?)\]\]/g;
                    let hasPlaceholder = placeholderRegex.test(text);
                    
                    // Reset regex state
                    placeholderRegex.lastIndex = 0;
                    
                    // Process text for placeholders
                    let processedText = text;
                    let placeholderMatch;
                    
                    while ((placeholderMatch = placeholderRegex.exec(text)) !== null) {
                        const placeholder = placeholderMatch[1].trim();
                        if (!result.foundPlaceholders.includes(placeholder)) {
                            result.foundPlaceholders.push(placeholder);
                        }
                        
                        processedText = processedText.replace(
                            placeholderMatch[0],
                            `<span class="placeholder">[[${placeholder}]]</span>`
                        );
                    }
                    
                    if (hasPlaceholder) {
                        placeholdersHtml += `<p style="font-size: 18px; margin-bottom: 12px;">${processedText}</p>`;
                    } else {
                        textHtml += `<p style="font-size: 16px; margin-bottom: 8px;">${text}</p>`;
                    }
                }
                
                result.textHtml = textHtml;
                result.placeholdersHtml = placeholdersHtml;
                
                // If no placeholders were found, we'll use defaults
                if (result.foundPlaceholders.length === 0) {
                    // Check if any text contains words that might indicate where placeholders should be
                    const nameIndicators = ['name', 'recipient', 'awarded to', 'presented to', 'certifies that'];
                    const awardIndicators = ['award', 'achievement', 'certificate', 'certification', 'completed'];
                    const sponsorIndicators = ['sponsor', 'presented by', 'organization', 'company', 'institution'];
                    const dateIndicators = ['date', 'day', 'issued', 'on the'];
                    
                    for (const text of textElements) {
                        const lowerText = text.toLowerCase();
                        
                        if (nameIndicators.some(indicator => lowerText.includes(indicator))) {
                            textHtml = textHtml.replace(text, text + ' <span class="placeholder">[[Name]]</span>');
                            if (!result.foundPlaceholders.includes('Name')) result.foundPlaceholders.push('Name');
                        }
                        else if (awardIndicators.some(indicator => lowerText.includes(indicator))) {
                            textHtml = textHtml.replace(text, text + ' <span class="placeholder">[[Award]]</span>');
                            if (!result.foundPlaceholders.includes('Award')) result.foundPlaceholders.push('Award');
                        }
                        else if (sponsorIndicators.some(indicator => lowerText.includes(indicator))) {
                            textHtml = textHtml.replace(text, text + ' <span class="placeholder">[[Sponsor]]</span>');
                            if (!result.foundPlaceholders.includes('Sponsor')) result.foundPlaceholders.push('Sponsor');
                        }
                        else if (dateIndicators.some(indicator => lowerText.includes(indicator))) {
                            textHtml = textHtml.replace(text, text + ' <span class="placeholder">[[Date]]</span>');
                            if (!result.foundPlaceholders.includes('Date')) result.foundPlaceholders.push('Date');
                        }
                    }
                }
            } catch (error) {
                console.error('Error extracting content from slide:', error);
            }
            
            return result;
        }

        // Get default placeholders HTML
        function getDefaultPlaceholdersHtml() {
            return `
                <p style="font-size: 18px; margin-bottom: 15px;">This certifies that</p>
                <p style="font-size: 24px; color: var(--primary-color); margin-bottom: 15px;"><span class="placeholder">[[Name]]</span></p>
                <p style="font-size: 18px; margin-bottom: 15px;">has successfully received</p>
                <p style="font-size: 20px; color: var(--primary-color); margin-bottom: 20px;"><span class="placeholder">[[Award]]</span></p>
                <p style="font-size: 16px; margin-bottom: 10px;">Sponsored by: <span class="placeholder">[[Sponsor]]</span></p>
                <p style="font-size: 16px;"><span class="placeholder">[[Date]]</span></p>
            `;
        }

        // Extract text content from slide XML
        function extractTextFromSlideXml(slideXml) {
            let html = '';
            
            // Extract text from a:t tags (text elements in PowerPoint XML)
            const textRegex = /<a:t[^>]*>([^<]*)<\/a:t>/g;
            let textMatch;
            while ((textMatch = textRegex.exec(slideXml)) !== null) {
                const text = textMatch[1].trim();
                if (text) {
                    // Check if this text contains a placeholder
                    const placeholderRegex = /\[\[(.*?)\]\]/g;
                    let processedText = text;
                    let hasPlaceholder = false;
                    
                    let placeholderMatch;
                    while ((placeholderMatch = placeholderRegex.exec(text)) !== null) {
                        hasPlaceholder = true;
                        const placeholder = placeholderMatch[1];
                        processedText = processedText.replace(
                            placeholderMatch[0], 
                            `<span class="placeholder">[[${placeholder}]]</span>`
                        );
                    }
                    
                    if (hasPlaceholder) {
                        html += `<p style="font-size: 18px; margin-bottom: 10px;">${processedText}</p>`;
                    } else {
                        html += `<p style="font-size: 16px; margin-bottom: 8px;">${text}</p>`;
                    }
                }
            }
            
            // If no text was found, show placeholder examples
            if (!html) {
                html = `
                    <p style="font-size: 18px; margin-bottom: 15px;">This certifies that</p>
                    <p style="font-size: 24px; color: var(--primary-color); margin-bottom: 15px;"><span class="placeholder">[[Name]]</span></p>
                    <p style="font-size: 18px; margin-bottom: 15px;">has successfully received</p>
                    <p style="font-size: 20px; color: var(--primary-color); margin-bottom: 20px;"><span class="placeholder">[[Award]]</span></p>
                    <p style="font-size: 16px; margin-bottom: 10px;">Sponsored by: <span class="placeholder">[[Sponsor]]</span></p>
                    <p style="font-size: 16px;"><span class="placeholder">[[Date]]</span></p>
                `;
            }
            
            return html;
        }

        // Highlight any placeholders in the preview
        function highlightPlaceholders() {
            setTimeout(() => {
                const regex = /\[\[(.*?)\]\]/g;
                const previewDiv = certificatePreview.querySelector('div');
                if (!previewDiv) return;
                
                const html = previewDiv.innerHTML;
                const newHtml = html.replace(regex, (match, placeholder) => {
                    return `<span class="placeholder">${match}</span>`;
                });
                
                previewDiv.innerHTML = newHtml;
            }, 100);
        }

        // Function to handle Excel data upload
        async function handleExcelDataUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            excelDataName.textContent = file.name;
            addLog(`Loading recipient data: ${file.name}`, 'info');
            
            try {
                const data = await file.arrayBuffer();
                const workbook = XLSX.read(data, { type: 'array' });
                
                // Get first sheet
                const sheetName = workbook.SheetNames[0];
                addLog(`Found sheet: ${sheetName}`, 'info');
                
                const sheet = workbook.Sheets[sheetName];
                
                // Convert to JSON
                excelData = XLSX.utils.sheet_to_json(sheet);
                
                if (excelData.length === 0) {
                    addLog('No data found in Excel file.', 'error');
                    showStatus('No data found in Excel file.', 'error');
                    return;
                }
                
                addLog(`Loaded ${excelData.length} recipient records`, 'success');
                
                // Populate table from Excel data
                populateTableFromExcel();
                
                showStatus('Recipient data loaded successfully. ' + excelData.length + ' records found.', 'success');
                generateCertsBtn.disabled = false;
            } catch (error) {
                console.error('Error processing Excel file:', error);
                addLog(`Error processing Excel file: ${error.message}`, 'error');
                showStatus('Error processing Excel file: ' + error.message, 'error');
            }
        }

        // Function to populate table from Excel data
        function populateTableFromExcel() {
            tableData = [];
            
            // Clear existing body rows
            const tbody = recipientTable.querySelector('tbody');
            tbody.innerHTML = '';
            
            // For each Excel row, create a table row
            excelData.forEach((row, index) => {
                const rowData = {
                    ID: row.ID || (index + 1).toString()
                };
                
                // Map Excel columns to placeholders - case-insensitive matching
                for (const placeholder in PLACEHOLDERS) {
                    // First try exact match
                    if (placeholder in row) {
                        rowData[placeholder] = row[placeholder];
                    } else {
                        // Try case-insensitive match
                        const lowercasePlaceholder = placeholder.toLowerCase();
                        let found = false;
                        
                        for (const key in row) {
                            if (key.toLowerCase() === lowercasePlaceholder) {
                                rowData[placeholder] = row[key];
                                found = true;
                                break;
                            }
                        }
                        
                        if (!found) {
                            rowData[placeholder] = '';
                        }

                        // special handling of 'Date'
                        if (placeholder == "Date"){
                            rowData[placeholder] = getCurrentFormattedDate();
                        }
                    }
                }
                
                // Add log entry for main identifier (use first available placeholder or ID)
                const identifier = Object.keys(PLACEHOLDERS).length > 0 ? 
                    (rowData[Object.keys(PLACEHOLDERS)[0]] || rowData.ID) : 
                    rowData.ID;
                    
                addLog(`Loaded data for recipient: ${identifier} (ID: ${rowData.ID})`, 'info');
                
                tableData.push(rowData);
                addTableRow(rowData);
            });
            
            // Enable generate button if we have data and placeholders
            if (tableData.length > 0 && Object.keys(PLACEHOLDERS).length > 0) {
                generateCertsBtn.disabled = false;
            } else {
                generateCertsBtn.disabled = true;
            }
        }

        // Helper to get current date formatted
        function getCurrentFormattedDate() {
            const date = new Date();
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
        }

        // Function to add an empty row to the table
        function addEmptyRow() {
            const emptyData = {
                ID: (tableData.length + 1).toString()
            };
            
            // Add all placeholders
            for (const placeholder in PLACEHOLDERS) {
                // Initialize with empty strings
                emptyData[placeholder] = '';
            }
            
            tableData.push(emptyData);
            addTableRow(emptyData);
            
            // Enable generate button if we have data
            if (tableData.length > 0 && Object.keys(PLACEHOLDERS).length > 0) {
                generateCertsBtn.disabled = false;
            }
        }

        // Function to add a row to the table with the given data
        function addTableRow(rowData) {
            const tbody = recipientTable.querySelector('tbody');
            const tr = document.createElement('tr');
            
            // Checkbox cell
            const checkboxCell = document.createElement('td');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'row-checkbox';
            checkbox.checked = true; // Default to checked
            checkboxCell.appendChild(checkbox);
            tr.appendChild(checkboxCell);
            
            // Actions cell
            const actionsCell = document.createElement('td');
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'Delete';
            deleteBtn.className = 'btn btn-accent btn-sm';
            deleteBtn.addEventListener('click', () => {
                const index = Array.from(tbody.children).indexOf(tr);
                tableData.splice(index, 1);
                tbody.removeChild(tr);
                
                // Disable generate button if no data
                if (tableData.length === 0) {
                    generateCertsBtn.disabled = true;
                }
            });
            actionsCell.appendChild(deleteBtn);
            tr.appendChild(actionsCell);
            
            // ID cell
            const idCell = document.createElement('td');
            const idInput = document.createElement('input');
            idInput.type = 'text';
            idInput.value = rowData.ID || '';
            idInput.addEventListener('input', (e) => {
                const index = Array.from(tbody.children).indexOf(tr);
                tableData[index].ID = e.target.value;
            });
            idCell.appendChild(idInput);
            tr.appendChild(idCell);
            
            // Data cells for all placeholders
            for (const placeholder in PLACEHOLDERS) {
                const td = document.createElement('td');
                const input = document.createElement('input');
                input.type = 'text';
                input.value = rowData[placeholder] || '';
                input.addEventListener('input', (e) => {
                    const index = Array.from(tbody.children).indexOf(tr);
                    tableData[index][placeholder] = e.target.value;
                });
                
                td.appendChild(input);
                tr.appendChild(td);
            }
            
            tbody.appendChild(tr);
        }

        // Function to select all rows
        function selectAllRows() {
            document.querySelectorAll('.row-checkbox').forEach(checkbox => {
                checkbox.checked = true;
            });
            selectAllCheckbox.checked = true;
        }

        // Function to deselect all rows
        function deselectAllRows() {
            document.querySelectorAll('.row-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            selectAllCheckbox.checked = false;
        }

        // Function to toggle all checkboxes
        function toggleAllCheckboxes() {
            const isChecked = selectAllCheckbox.checked;
            document.querySelectorAll('.row-checkbox').forEach(checkbox => {
                checkbox.checked = isChecked;
            });
        }

        // Function to generate certificates for selected rows
        async function generateSelectedCertificates() {
            // Check if we have a PowerPoint template
            if (!pptxZip) {
                showStatus('Please upload a PowerPoint template first.', 'error');
                return;
            }
            
            const checkboxes = document.querySelectorAll('.row-checkbox');
            const selectedIndices = [];
            
            checkboxes.forEach((checkbox, index) => {
                if (checkbox.checked) {
                    selectedIndices.push(index);
                }
            });
            
            if (selectedIndices.length === 0) {
                showStatus('Please select at least one recipient.', 'error');
                return;
            }
            
            addLog(`Generating certificates for ${selectedIndices.length} selected recipients...`, 'info');
            showStatus(`Generating ${selectedIndices.length} certificates...`, 'success');
            
            // Show progress bar
            progressBarContainer.classList.remove('hidden');
            progressBar.style.width = '0%';
            
            // Show log container
            logContainer.classList.remove('hidden');
            
            try {
                // For each selected recipient
                for (let i = 0; i < selectedIndices.length; i++) {
                    const index = selectedIndices[i];
                    const rowData = tableData[index];
                    
                    // Update progress
                    const progress = Math.round((i / selectedIndices.length) * 100);
                    progressBar.style.width = progress + '%';
                    
                    // Get ID for filename
                    const fileId = rowData.ID.toString().replace(/[^\w\-]/g, '_');
                    
                    addLog(`Processing certificate for: ${rowData.Name} (ID: ${fileId})...`, 'info');
                    
                    // Create PPTX with replaced placeholders
                    const pptxBlob = await createModifiedPPTX(rowData, fileId);
                    saveAs(pptxBlob, `${fileId}.pptx`);
                    addLog(`Generated PowerPoint certificate: ${fileId}.pptx`, 'success');
                    
                    // Create and save PDF version
                    const pdfBlob = await convertPPTXtoPDF(pptxBlob, rowData, fileId);
                    saveAs(pdfBlob, `${fileId}.pdf`);
                    addLog(`Generated PDF certificate: ${fileId}.pdf`, 'success');
                }
                
                // Complete progress bar
                progressBar.style.width = '100%';
                
                addLog(`Successfully generated ${selectedIndices.length} certificates in both PPTX and PDF formats.`, 'success');
                showStatus(`Successfully generated ${selectedIndices.length} certificates.`, 'success');
                
                // Hide progress bar after a delay
                setTimeout(() => {
                    progressBarContainer.classList.add('hidden');
                }, 3000);
                
            } catch (error) {
                console.error('Error generating certificates:', error);
                addLog(`Error generating certificates: ${error.message}`, 'error');
                showStatus('Error generating certificates: ' + error.message, 'error');
                progressBarContainer.classList.add('hidden');
            }
        }

        // Function to create a modified PPTX with replaced placeholders
        async function createModifiedPPTX(rowData, fileId) {
            try {
                // Clone the zip to avoid modifying the original
                const newZip = new JSZip();
                
                // Copy all files from the original zip
                for (const filename of Object.keys(pptxZip.files)) {
                    const file = pptxZip.files[filename];
                    if (!file.dir) {
                        const content = await pptxZip.file(filename).async('arraybuffer');
                        newZip.file(filename, content);
                    } else {
                        newZip.folder(filename);
                    }
                }
                
                // Get identifier for logging
                const identifier = Object.keys(PLACEHOLDERS).length > 0 ? 
                    (rowData[Object.keys(PLACEHOLDERS)[0]] || fileId) : 
                    fileId;
                    
                addLog(`Replacing placeholders in certificate for ${identifier}...`, 'info');
                
                // Get all slide XML files
                const slideFiles = [];
                for (const filename of Object.keys(newZip.files)) {
                    if (filename.startsWith('ppt/slides/slide') && filename.endsWith('.xml')) {
                        slideFiles.push(filename);
                    }
                }
                
                // Replace placeholders in each slide
                for (const slideFile of slideFiles) {
                    let slideXml = await newZip.file(slideFile).async("text");
                    
                    // Replace each detected placeholder
                    for (const placeholder in PLACEHOLDERS) {
                        const value = rowData[placeholder] || '';
                        const safeValue = value
                            .replace(/&/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;')
                            .replace(/"/g, '&quot;');
                            
                        const regex = new RegExp(`\\[\\[${placeholder}\\]\\]`, 'g');
                        slideXml = slideXml.replace(regex, safeValue);
                    }
                    
                    // Update the slide XML
                    newZip.file(slideFile, slideXml);
                }
                
                // Generate the modified PPTX
                const modifiedPptx = await newZip.generateAsync({
                    type: "blob",
                    mimeType: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                });
                
                return modifiedPptx;
                
            } catch (error) {
                console.error('Error creating modified PPTX:', error);
                addLog(`Error creating modified PPTX: ${error.message}`, 'error');
                throw error;
            }
        }

        // Function to convert PPTX to PDF
        async function convertPPTXtoPDF(pptxBlob, rowData, fileId) {
            try {
                addLog(`Creating PDF certificate for ${rowData.Name}...`, 'info');
                
                // Try cloud conversion service first
                try {
                    const pdfBlob = await tryCloudConversion(pptxBlob, fileId);
                    if (pdfBlob) {
                        return pdfBlob;
                    }
                } catch (cloudError) {
                    addLog(`Cloud conversion failed: ${cloudError.message}. Falling back to client-side rendering.`, 'warning');
                }
                
                // If cloud conversion fails, render a PDF using client-side methods
                return await renderCertificateToPDF(rowData, fileId);
                
            } catch (error) {
                console.error('Error converting to PDF:', error);
                addLog(`Error creating PDF: ${error.message}. Creating simple PDF version.`, 'error');
                
                // Last resort: create a simple PDF with recipient info
                return createSimplePDF(rowData, fileId);
            }
        }

        // Try to convert using a cloud conversion service
        async function tryCloudConversion(pptxBlob, fileId) {
            // generate key from https://cloudconvert.com/dashboard/api/v2/keys
            const API_KEY = ''; 
            
            if (!API_KEY) {
                // Skip cloud conversion if no API key
                return null;
            }
            
            
            try {
                addLog(`Creating PDF for ${fileId} using CloudConvert...`, 'info');
                
                // Step 1: Create a job
                const createJobResponse = await fetch('https://api.cloudconvert.com/v2/jobs', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${API_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        "tasks": {
                            "upload-my-file": {
                                "operation": "import/upload"
                            },
                            "convert-my-file": {
                                "operation": "convert",
                                "input": "upload-my-file",
                                "output_format": "pdf",
                                "some_other_option": "value"
                            },
                            "export-my-file": {
                                "operation": "export/url",
                                "input": "convert-my-file"
                            }
                        }
                    })
                });

                if (!createJobResponse.ok) {
                    const errorText = await createJobResponse.text();
                    throw new Error(`Failed to create job: ${createJobResponse.status} ${createJobResponse.statusText} - ${errorText}`);
                }

                const jobData = await createJobResponse.json();
                const jobId = jobData.data.id;
                
                // Step 2: Upload the file to the provided upload URL
                const uploadTask = jobData.data.tasks.find(task => task.name === 'upload-my-file');
                const uploadUrl = uploadTask.result.form.url;
                const formData = new FormData();
                
                // Add all the form fields from the result
                Object.entries(uploadTask.result.form.parameters).forEach(([key, value]) => {
                    formData.append(key, value);
                });
                
                // Add the file
                formData.append('file', pptxBlob, `${fileId}.pptx`);
                
                const uploadResponse = await fetch(uploadUrl, {
                    method: 'POST',
                    body: formData
                });
                
                if (!uploadResponse.ok) {
                    throw new Error(`File upload failed: ${uploadResponse.status} ${uploadResponse.statusText}`);
                }
                
                addLog(`File uploaded successfully for ${fileId}, waiting for conversion...`, 'info');
                
                // Step 3: Wait for the job to complete and get the result directly
                const waitTime = 10000; // Wait 10 seconds for the conversion to complete
                await new Promise(resolve => setTimeout(resolve, waitTime));
                
                const jobStatusResponse = await fetch(`https://api.cloudconvert.com/v2/jobs/${jobId}`, {
                    headers: {
                        'Authorization': `Bearer ${API_KEY}`
                    }
                });
                
                if (!jobStatusResponse.ok) {
                    throw new Error(`Job status check failed: ${jobStatusResponse.status} ${jobStatusResponse.statusText}`);
                }
                
                const jobStatus = await jobStatusResponse.json();
                const exportTask = jobStatus.data.tasks.find(task => task.name === 'export-my-file');
                
                // Check if any task failed
                const failedTask = jobStatus.data.tasks.find(task => task.status === 'error');
                if (failedTask) {
                    throw new Error(`Conversion failed: ${failedTask.message || 'Unknown error'}`);
                }
                
                if (!exportTask || exportTask.status !== 'finished') {
                    throw new Error('Conversion not completed within the allocated time');
                }
                
                // Step 4: Download the converted file
                if (!exportTask.result || !exportTask.result.files || exportTask.result.files.length === 0) {
                    throw new Error('No output file found in the conversion result');
                }
                
                const downloadUrl = exportTask.result.files[0].url;
                const pdfResponse = await fetch(downloadUrl);
                
                if (!pdfResponse.ok) {
                    throw new Error(`PDF download failed: ${pdfResponse.status} ${pdfResponse.statusText}`);
                }
                
                const pdfBlob = await pdfResponse.blob();
                addLog(`PDF conversion successful for ${fileId}`, 'success');
                return pdfBlob;
                
            } catch (error) {
                addLog(`Server conversion failed, falling back to client-side method: ${error.message}`, 'warning');
                return null;
            }
        }

        // Render a certificate PDF on the client side
        async function renderCertificateToPDF(rowData, fileId) {
            addLog(`Rendering certificate PDF...`, 'info');
            
            // Get identifier for display
            const identifier = Object.keys(PLACEHOLDERS).length > 0 ? 
                (rowData[Object.keys(PLACEHOLDERS)[0]] || fileId) : 
                fileId;
            
            // Create a visual representation of the certificate
            let placeholdersHtml = '';
            
            // Generate HTML for all placeholders
            for (const placeholder in PLACEHOLDERS) {
                const value = rowData[placeholder] || '';
                placeholdersHtml += `
                    <div style="margin: 10px 0;">
                        <strong>${placeholder}:</strong> ${value}
                    </div>
                `;
            }
            
            // If no placeholders were detected
            if (placeholdersHtml === '') {
                placeholdersHtml = `<div style="margin: 15px 0;">No placeholders found in template</div>`;
            }
            
            const certificateHtml = `
                <div id="certificate-container" style="width: 8.5in; height: 11in; padding: 0.5in; background-color: white; position: relative; font-family: 'Times New Roman', serif;">
                    <div style="border: 2px solid #c9a343; height: 100%; width: 100%; padding: 0.25in; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center;">
                        <div style="font-size: 24pt; color: #444; margin-bottom: 0.5in;">CERTIFICATE</div>
                        <div style="font-size: 14pt; margin-bottom: 0.3in;">ID: ${fileId}</div>
                        <div style="width: 80%; text-align: left;">
                            ${placeholdersHtml}
                        </div>
                        <div style="display: flex; justify-content: space-between; width: 80%; margin-top: 0.7in;">
                            <div style="text-align: center; border-top: 1px solid #666; padding-top: 0.1in; width: 40%;">Signature</div>
                            <div style="text-align: center; border-top: 1px solid #666; padding-top: 0.1in; width: 40%;">Date</div>
                        </div>
                    </div>
                </div>
            `;
            
            // Create a temporary container
            const container = document.createElement('div');
            container.style.position = 'fixed';
            container.style.left = '-9999px';
            container.style.top = '0';
            container.innerHTML = certificateHtml;
            document.body.appendChild(container);
            
            try {
                // Render to canvas
                const canvas = await html2canvas(container.querySelector('#certificate-container'), {
                    scale: 2, // Higher resolution
                    useCORS: true,
                    allowTaint: true,
                    backgroundColor: '#ffffff'
                });
                
                // Convert to PDF
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'in',
                    format: 'letter'
                });
                
                // Add the image to the PDF (fitting to page)
                const imgData = canvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, 8.5, 11);
                
                // Clean up
                document.body.removeChild(container);
                
                addLog(`PDF rendering complete for ${identifier}`, 'success');
                return pdf.output('blob');
                
            } catch (error) {
                console.error('Error rendering certificate:', error);
                document.body.removeChild(container);
                throw error;
            }
        }

        // Create a simple fallback PDF with just the text
        function createSimplePDF(rowData, fileId) {
            // Get identifier for display
            const identifier = Object.keys(PLACEHOLDERS).length > 0 ? 
                (rowData[Object.keys(PLACEHOLDERS)[0]] || fileId) : 
                fileId;
                
            addLog(`Creating simple PDF certificate for ${identifier}...`, 'info');
            
            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'in',
                    format: 'letter'
                });
                
                // Add certificate content
                pdf.setFontSize(24);
                pdf.setTextColor(68, 68, 68);
                pdf.text('CERTIFICATE', 4.25, 2, { align: 'center' });
                
                pdf.setFontSize(14);
                pdf.text(`ID: ${fileId}`, 4.25, 3, { align: 'center' });
                
                // Add all placeholders
                let yPosition = 4;
                for (const placeholder in PLACEHOLDERS) {
                    const value = rowData[placeholder] || '';
                    pdf.setFontSize(12);
                    pdf.text(`${placeholder}: ${value}`, 1, yPosition);
                    yPosition += 0.5;
                }
                
                // Draw signature lines
                pdf.line(2, 9, 4, 9);
                pdf.line(5, 9, 7, 9);
                pdf.setFontSize(12);
                pdf.text('Signature', 3, 9.3, { align: 'center' });
                pdf.text('Date', 6, 9.3, { align: 'center' });
                
                addLog(`Simple PDF created for ${identifier}`, 'success');
                return pdf.output('blob');
                
            } catch (error) {
                console.error('Error creating simple PDF:', error);
                throw error;
            }
        }

        // Function to show status message
        function showStatus(message, type) {
            statusMessage.textContent = message;
            statusMessage.className = 'status-message ' + type;
            statusMessage.classList.remove('hidden');
            
            if (type === 'success') {
                setTimeout(() => {
                    statusMessage.classList.add('hidden');
                }, 5000);
            }
        }

        // Function to add log entry
        function addLog(message, type) {
            logContainer.classList.remove('hidden');
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            logEntries.appendChild(logEntry);
            logEntries.scrollTop = logEntries.scrollHeight;
        }

        // Initialize with some default data on page load
        function init() {
            // Start with an empty table that just has the ID column
            const thead = recipientTable.querySelector('thead');
            const headerRow = thead.querySelector('tr');
            
            // Keep just the checkbox and actions columns
            while (headerRow.children.length > 2) {
                headerRow.removeChild(headerRow.lastChild);
            }
            
            // Add ID column
            const idTh = document.createElement('th');
            idTh.textContent = 'ID';
            headerRow.appendChild(idTh);
            
            // Clear the table body
            const tbody = recipientTable.querySelector('tbody');
            tbody.innerHTML = '';
            
            // Initialize with empty table data
            tableData = [];
            
            // Add initial empty row
            addEmptyRow();
            
            // Disable buttons until template is loaded
            addRowBtn.disabled = true;
            selectAllBtn.disabled = true;
            deselectAllBtn.disabled = true;
            generateCertsBtn.disabled = true;
            
            addLog('Certificate Generator ready. Upload a PPTX template with [[placeholder]] format to begin.', 'info');
        }

        // Run initialization
        init();
    </script>
</body>
</html>