<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reference Verification Tool</title>
    <link rel="icon" href="https://nuwanjanaka.info/wp-content/uploads/2016/10/cropped-SiteIcon1-180x180.png"
          type="image/png">
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #e9f0f9;
            --accent-color: #2ecc71;
            --danger-color: #e74c3c;
            --text-color: #333;
            --light-gray: #f5f5f5;
            --border-color: #ddd;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            color: var(--text-color);
            line-height: 1.6;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #f8f9fa;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 20px;
            text-align: center;
        }

        h2 {
            color: var(--primary-color);
            margin-bottom: 15px;
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 5px;
        }

        .home-menu {
            display: flex;
            align-items: center;
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: white;
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            text-decoration: none;
            color: var(--primary-color);
            font-weight: bold;
        }

        .home-menu:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateY(-2px);
        }

        .home-menu .icon {
            margin-right: 8px;
            display: flex;
            align-items: center;
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
            margin-top: 40px;
        }

        .column {
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .api-settings-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }

        label {
            font-weight: 600;
            display: block;
            margin-bottom: 5px;
        }

        input[type="password"],
        select,
        textarea {
            width: 100%;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            font-size: 0.95rem;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        input[type="password"]:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 111, 165, 0.1);
        }

        textarea {
            resize: vertical;
            min-height: 150px;
        }

        button, .button {
            padding: 12px;
            border: none;
            color: white;
            font-size: 1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .button-primary {
            background-color: var(--primary-color);
        }

        .button-primary:hover:not(:disabled) {
            background-color: #3b5a8c;
            transform: translateY(-2px);
        }

        .button-secondary {
            background-color: #6c757d;
        }

        .button-secondary:hover:not(:disabled) {
            background-color: #5a6268;
            transform: translateY(-2px);
        }

        .button-success {
            background-color: var(--accent-color);
        }

        .button-success:hover:not(:disabled) {
            background-color: #27ae60;
            transform: translateY(-2px);
        }

        .button-danger {
            background-color: var(--danger-color);
        }

        .button-danger:hover:not(:disabled) {
            background-color: #c0392b;
            transform: translateY(-2px);
        }

        .results-container {
            background-color: var(--light-gray);
            padding: 20px;
            border-radius: 6px;
            min-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background-color: white;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background-color: var(--secondary-color);
            color: var(--primary-color);
            font-weight: 600;
        }

        tr:hover {
            background-color: #f8f9fa;
        }

        .status-verified {
            color: var(--accent-color);
            font-weight: 600;
        }

        .status-error {
            color: var(--danger-color);
            font-weight: 600;
        }

        .status-warning {
            color: #f39c12;
            font-weight: 600;
        }

        .link-button {
            color: var(--primary-color);
            text-decoration: none;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .link-button:hover {
            background-color: var(--secondary-color);
        }

        .feedback-cell {
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .feedback-verified {
            color: var(--accent-color);
        }

        .feedback-error {
            color: var(--danger-color);
        }

        .feedback-warning {
            color: #f39c12;
        }

        .checkbox-cell {
            text-align: center;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .status-message {
            font-size: 0.85rem;
            color: #666;
            margin-top: 4px;
        }

        .progress-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            margin: 15px 0;
            display: none;
        }

        .progress-bar {
            height: 30px;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .extraction-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 5px;
        }

        .badge-local {
            background-color: #d4edda;
            color: #155724;
        }

        .badge-llm {
            background-color: #cce5ff;
            color: #004085;
        }

        @media (max-width: 768px) {
            .api-settings-grid {
                grid-template-columns: 1fr;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: 8px;
            }
        }

        /* Verification Result Styles */
        .verification-result {
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
            line-height: 1.5;
        }

        .verification-result.feedback-verified {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
        }

        .verification-result.feedback-warning {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
        }

        .verification-result.feedback-error {
            background-color: #f8d7da;
            border-left: 4px solid #dc3545;
        }

        /* Status Line */
        .verification-status {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .status-icon {
            font-size: 18px;
            font-weight: bold;
        }

        .status-message {
            font-weight: 500;
            flex: 1;
        }

        /* Source Badge */
        .verification-source {
            margin-bottom: 8px;
        }

        .source-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .source-doi {
            background-color: #007bff;
            color: white;
        }

        .source-crossref {
            background-color: #17a2b8;
            color: white;
        }

        .source-semantic {
            background-color: #6f42c1;
            color: white;
        }

        .source-openalex {
            background-color: #fd7e14;
            color: white;
        }

        .source-google {
            background-color: #e83e8c;
            color: white;
        }

        .source-llm {
            background-color: #6c757d;
            color: white;
        }

        .source-default {
            background-color: #6c757d;
            color: white;
        }

        /* Confidence Badge */
        .verification-confidence {
            margin-bottom: 8px;
        }

        .confidence-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }

        .confidence-high {
            background-color: #28a745;
            color: white;
        }

        .confidence-medium {
            background-color: #ffc107;
            color: #000;
        }

        .confidence-low {
            background-color: #dc3545;
            color: white;
        }

        /* Details Section */
        .verification-details {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .detail-row {
            margin-bottom: 6px;
            font-size: 13px;
        }

        .detail-row.mismatch {
            color: #856404;
        }

        .detail-row.match {
            color: #155724;
        }

        .detail-label {
            font-weight: 600;
            margin-right: 6px;
        }

        .detail-value {
            color: inherit;
        }

        .canonical-link {
            color: #007bff;
            text-decoration: none;
            word-break: break-all;
        }

        .canonical-link:hover {
            text-decoration: underline;
        }

        .external-icon {
            font-size: 12px;
            margin-left: 4px;
        }

        /* Warning */
        .verification-warning {
            margin-top: 8px;
            padding: 8px;
            background-color: rgba(255, 193, 7, 0.2);
            border-radius: 4px;
            font-size: 12px;
            color: #856404;
        }

        /* Cache Indicator */
        .cache-indicator {
            margin-top: 8px;
        }

        .cache-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            background-color: #e7f3ff;
            color: #004085;
        }

        /* Manual Verification */
        .manual-verification {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .manual-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background-color: #007bff;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .manual-link:hover {
            background-color: #0056b3;
            text-decoration: none;
        }

        /* Compact view for table cells */
        .feedback-cell {
            display: block;
            width: 100%;
        }

    </style>
</head>
<body>

<a class="home-menu" href="../">
    <span class="icon">
        <svg xmlns="http://www.w3.org/2000/svg" height="18" width="18" fill="currentColor" viewBox="0 0 24 24">
            <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
        </svg>
    </span>
    Home
</a>

<h1>ðŸ“š Reference Verification Tool (Citation Checker)</h1>

<div class="main-container">
    <!-- API Settings -->
    <div class="column">
        <h2>[Optional] API Settings</h2>
        <div class="api-settings-grid">
            <div>
                <label for="apiKey">Gemini API Key (for enhanced extraction & verification)</label>
                <input type="password" id="apiKey" placeholder="Enter your Gemini API key">
                <small class="status-message">Stored locally in your browser. Used for fallback extraction and automatic
                    verification.</small>
            </div>

            <div>
                <label for="modelSelect">Model</label>
                <select id="modelSelect" disabled>
                    <option value="">Enter API Key to load models</option>
                </select>
                <small id="modelStatus" class="status-message"></small>
            </div>
        </div>
    </div>

    <!-- References Input -->
    <div class="column">
        <h2>Paste References / Citations</h2>
        <label for="referencesInput">Enter your references (supports numbered format [1], [2], etc. or blank line
            separation)</label>
        <small class="status-message">Keep references minimal to stay within Gemini free tier/request limits.</small>
        <textarea id="referencesInput" placeholder="Example:
[1] Smith, J., & Johnson, A. (2023). Understanding Machine Learning. Journal of AI Research, 45(2), 123-145. https://doi.org/10.1234/example.2023
[2] Brown, K. (2022). Data Science Fundamentals. Academic Press. http://example.com/paper

Or without numbers:
Smith, J., & Johnson, A. (2023). Understanding Machine Learning...

Brown, K. (2022). Data Science Fundamentals..."></textarea>


        <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar">0%</div>
        </div>

        <button id="processButton" class="button-primary">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.267.267 0 0 1 .02-.022z"/>
            </svg>
            Process & Verify References
        </button>
    </div>

    <!-- Verification Results -->
    <div class="column">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h2 style="margin-bottom: 0;">Verification Results</h2>
            <button id="exportButton" class="button-secondary" style="padding: 8px 15px; display: none;">
                Export Selected (CSV)
            </button>
        </div>

        <div id="resultsContainer" class="results-container">
            <div style="text-align: center; color: #666; padding: 40px 20px;">
                Your verification results will appear here after processing.
            </div>
        </div>
    </div>
</div>

<script>
    // Storage utilities
    const storage = {
        get: (key) => localStorage.getItem(key),
        set: (key, value) => localStorage.setItem(key, value)
    };

    // DOM elements
    const ui = {
        apiKeyInput: document.getElementById('apiKey'),
        modelSelect: document.getElementById('modelSelect'),
        modelStatus: document.getElementById('modelStatus'),
        referencesInput: document.getElementById('referencesInput'),
        processButton: document.getElementById('processButton'),
        resultsContainer: document.getElementById('resultsContainer'),
        exportButton: document.getElementById('exportButton'),
        progressContainer: document.getElementById('progressContainer'),
        progressBar: document.getElementById('progressBar')
    };

    // API configuration
    const API_CONFIG = {
        apiListModelsUrl: (apiKey) => `https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`,
        apiGenerateUrl: (apiKey, model) => `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`
    };

    // Helper to extract JSON from markdown code blocks
    function safeJSONParse(text) {
        try {
            return JSON.parse(text);
        } catch (e) {
            const firstBracket = text.indexOf('[');
            const lastBracket = text.lastIndexOf(']');
            if (firstBracket !== -1 && lastBracket !== -1) {
                return JSON.parse(text.substring(firstBracket, lastBracket + 1));
            }
            throw e;
        }
    }

    // Helper for waiting
    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

    const GOOGLE_SCHOLAR_API = 'https://scholar.google.com/scholar?hl=en&q=';

    // Initialize
    ui.apiKeyInput.value = storage.get('geminiApiKey') || '';
    const savedModel = storage.get('geminiModel') || '';

    // Update progress bar
    function updateProgress(current, total, message = '') {
        const percentage = Math.round((current / total) * 100);
        ui.progressBar.style.width = percentage + '%';
        ui.progressBar.textContent = message || `Processing ${current}/${total} (${percentage}%)`;
    }

    // Show/hide progress bar
    function showProgress() {
        ui.progressContainer.style.display = 'block';
    }

    function hideProgress() {
        ui.progressContainer.style.display = 'none';
        ui.progressBar.style.width = '0%';
        ui.progressBar.textContent = '0%';
    }

    // Fetch available models
    async function fetchAvailableModels(apiKey) {
        if (!apiKey) {
            ui.modelSelect.innerHTML = '<option value="">Enter API Key to load models</option>';
            ui.modelSelect.disabled = true;
            ui.modelStatus.textContent = '';
            return;
        }

        ui.modelSelect.disabled = true;
        ui.modelSelect.innerHTML = '<option>Loading models...</option>';
        ui.modelStatus.textContent = 'Fetching available models...';

        try {
            const response = await fetch(API_CONFIG.apiListModelsUrl(apiKey));

            if (!response.ok) {
                throw new Error('Failed to fetch models. Check API key.');
            }

            const data = await response.json();
            const models = data.models
                .filter(model => model.supportedGenerationMethods &&
                    model.supportedGenerationMethods.includes('generateContent'))
                .map(model => model.name.replace('models/', ''));

            if (models.length === 0) {
                throw new Error('No compatible models found for this API key.');
            }

            ui.modelSelect.innerHTML = '';
            models.forEach(modelName => {
                const option = document.createElement('option');
                option.value = modelName;
                option.textContent = modelName.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                ui.modelSelect.appendChild(option);
            });

            // Select saved model or default
            if (savedModel && models.includes(savedModel)) {
                ui.modelSelect.value = savedModel;
            } else if (models.includes('gemini-flash-latest')) {
                ui.modelSelect.value = 'gemini-flash-latest';
            } else if (models.includes('gemini-2.5-flash')) {
                ui.modelSelect.value = 'gemini-2.5-flash';
            } else {
                ui.modelSelect.value = models[0];
            }

            storage.set('geminiModel', ui.modelSelect.value);
            ui.modelStatus.textContent = `${models.length} models available`;
            ui.modelSelect.disabled = false;

        } catch (error) {
            console.error(error);
            ui.modelSelect.innerHTML = '<option value="">Error loading models</option>';
            ui.modelStatus.textContent = `Error: ${error.message}`;
            ui.modelSelect.disabled = true;
        }
    }

    // Load models on init if API key exists
    if (ui.apiKeyInput.value) {
        fetchAvailableModels(ui.apiKeyInput.value);
    }

    // Save API key and fetch models on change
    ui.apiKeyInput.addEventListener('change', () => {
        const apiKey = ui.apiKeyInput.value.trim();
        storage.set('geminiApiKey', apiKey);
        fetchAvailableModels(apiKey);
    });

    // Save model selection
    ui.modelSelect.addEventListener('change', () => {
        storage.set('geminiModel', ui.modelSelect.value);
    });

    class VerificationCache {
        constructor(ttl = 3600000) { // 1 hour default
            this.cache = new Map();
            this.ttl = ttl;
        }

        key(ref) {
            return `${ref.doi || ref.title}-${ref.authors}-${ref.year}`;
        }

        get(ref) {
            const entry = this.cache.get(this.key(ref));
            if (!entry) return null;
            if (Date.now() - entry.timestamp > this.ttl) {
                this.cache.delete(this.key(ref));
                return null;
            }
            return entry.data;
        }

        set(ref, data) {
            this.cache.set(this.key(ref), {
                data,
                timestamp: Date.now()
            });
        }
    }

    const verificationCache = new VerificationCache();

    // Rate Limiter Class
    class RateLimiter {
        constructor(delay = 1000) {
            this.delay = delay;
            this.lastRequest = 0;
        }

        async throttle() {
            const now = Date.now();
            const timeSinceLastRequest = now - this.lastRequest;

            if (timeSinceLastRequest < this.delay) {
                await new Promise(resolve =>
                    setTimeout(resolve, this.delay - timeSinceLastRequest)
                );
            }

            this.lastRequest = Date.now();
        }
    }

    const rateLimiter = new RateLimiter();


    async function extractBatchWithLLM(references, maxRetries = 3, baseDelay = 4000) {
        const apiKey = storage.get('geminiApiKey');
        const model = storage.get('geminiModel');

        if (!apiKey || !model || !references || !Array.isArray(references) || references.length === 0) {
            return [];
        }

        console.debug('extractBatchWithLLM');

        // We send an object structure to the LLM so it knows exactly which text belongs to which ID.
        const indexedReferences = references.map((ref, index) => ({
            id: index, // explicit tracking ID
            text: String(ref).trim() // Ensure string and trim
        }));

        // Safe serialization for the prompt (Avoids the comma-join bug)
        const promptPayload = JSON.stringify(indexedReferences, null, 2);

        const prompt = `You are a specialized citation parsing engine.
Input: A JSON list of academic references, each with an 'id' and 'text'.
Task: Parse the 'text' into structured metadata.

STRICT OUTPUT RULES:
1. Return ONLY a valid JSON array.
2. The output array must contain objects corresponding to the input.
3. INCLUDE the 'id' from the input in the output object to ensure matching.
4. If a field is not found, use "".

FIELDS:
- id (integer, copy from input)
- title (string)
- authors (string, keep original order)
- year (string, 4 digits or "")
- doi (string, identifier only, 10.xxx/xxx)
- url (string)

INPUT DATA:
${promptPayload}

OUTPUT FORMAT EXAMPLE:
[
  {
    "id": 0,
    "title": "Title 1",
    "authors": "Author A; Author B",
    "year": "2023",
    "doi": "10.1234/example.doi",
    "url": "https://doi.org/10.1234/example.doi"
  },
  {
    "id": 1,
    "title": "Title 2",
    "authors": "Author C",
    "year": "2022",
    "doi": "",
    "url": ""
  }
]`;

        // RETRY LOOP
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            let text = null;
            try {
                const response = await fetch(API_CONFIG.apiGenerateUrl(apiKey, model), {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        contents: [{
                            parts: [{text: prompt}]
                        }],
                        generationConfig: {
                            temperature: 0, // Deterministic
                            maxOutputTokens: 8192, // Increased for batch processing
                            responseMimeType: "application/json" // Enforce JSON mode
                        }
                    })
                });

                // Specific handling for Rate Limits (429)
                if (response.status === 429) {
                    throw new Error('Rate Limit Exceeded (429)');
                }

                // Handle other HTTP errors
                if (!response.ok) {
                    throw new Error(`HTTP Error: ${response.status}`);
                }

                const data = await response.json();
                text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';

                // Even in JSON mode, verify the string isn't empty
                if (!text) {
                    throw new Error('Empty response from LLM');
                }

                console.debug(`LLM response text: [${text}]`);

                // Attempt to parse directly first (JSON mode usually returns clean JSON)
                const parsedData = safeJSONParse(text);

                // Create a map of ID -> Extracted Data
                const resultsMap = new Map();
                parsedData.forEach(item => {
                    if (item && typeof item.id !== 'undefined') {
                        resultsMap.set(item.id, item);
                    }
                });

                // If the LLM missed an item, we return a blank object or the original text to avoid shifting
                return indexedReferences.map(ref => {
                    const extracted = resultsMap.get(ref.id);
                    if (extracted) {
                        // Remove internal ID before returning
                        const { id, ...cleanData } = extracted;
                        return cleanData;
                    }
                    // Fallback for failed items
                    return { title: "", authors: "", year: "", doi: "", url: "", error: "Extraction failed" };
                });

            } catch (error) {
                // Log the failure
                console.warn(`Batch extraction attempt ${attempt}/${maxRetries} failed: ${error.message}, response text: [${text}]`);

                // If we have retries left, wait and loop again
                if (attempt < maxRetries) {
                    // Exponential Backoff: 4s -> 8s -> 16s
                    const jitter = Math.random() * 1000;
                    const waitTime = (baseDelay * Math.pow(2, attempt - 1)) + jitter;
                    console.log(`Retrying in ${waitTime}ms...`);
                    await delay(waitTime);
                } else {
                    // No retries left
                    console.error('All batch retry attempts exhausted.');
                    return [];
                }
            }
        }
    }


    // Enhanced reference extraction with improved logic
    function extractReferenceInfo(reference) {
        const result = {
            original: reference,
            title: '',
            authors: '',
            doi: '',
            url: '',
            year: '',
            detectedStyle: 'unknown',
            warnings: [],
            extractionMethod: 'local'
        };

        if (!reference || typeof reference !== 'string') {
            result.warnings.push('Invalid input: reference must be a non-empty string');
            return result;
        }

        let cleanRef = reference.trim();

        if (cleanRef.length < 10) {
            result.warnings.push('Reference text appears too short');
            return result;
        }

        // Normalize common unicode characters
        cleanRef = normalizeUnicode(cleanRef);

        // Step 1: Detect citation style
        result.detectedStyle = detectCitationStyle(cleanRef);

        // Step 2: Extract DOI (multiple formats)
        const doiResult = extractDOI(cleanRef);
        result.doi = doiResult.doi;
        cleanRef = doiResult.remaining;

        // Step 3: Extract URLs (non-DOI)
        const urlResult = extractURL(cleanRef);
        result.url = urlResult.url;
        cleanRef = urlResult.remaining;

        // Step 4: Extract year
        const yearResult = extractYear(cleanRef, result.detectedStyle);
        result.year = yearResult.year;
        cleanRef = yearResult.remaining;

        // Step 5: Extract authors based on detected style
        const authorResult = extractAuthors(cleanRef, result.detectedStyle);
        result.authors = authorResult.authors;
        cleanRef = authorResult.remaining;

        // Step 6: Extract title based on detected style
        const titleResult = extractTitle(cleanRef, result.detectedStyle);
        result.title = titleResult.title;

        // Step 7: Validate and add warnings
        validateResults(result);

        // Step 8: Clean all fields
        cleanAllFields(result);

        return result;
    }

    function normalizeUnicode(text) {
        return text
            .replace(/[\u2018\u2019\u201A\u201B]/g, "'")  // Smart single quotes
            .replace(/[\u201C\u201D\u201E\u201F]/g, '"')  // Smart double quotes
            .replace(/[\u2013\u2014]/g, '-')              // En/em dashes
            .replace(/\u2026/g, '...')                     // Ellipsis
            .replace(/\u00A0/g, ' ')                       // Non-breaking space
            .replace(/&amp;/g, '&')                        // HTML entities
            .replace(/&nbsp;/g, ' ')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/\s+/g, ' ');                         // Normalize whitespace
    }

    function detectCitationStyle(reference) {
        const ref = reference.trim();

        // -----------------------------------------------------------
        // 1. NUMBERED REFERENCES: [1], 1., (1)
        // -----------------------------------------------------------
        if (/^\s*\[?\d+\]?\.?\s/.test(ref)) {

            // PRIORITY 1: Web References (ACM Web / Generic Web)
            // Pattern: [...] ... Retrieved/Accessed ... from ... http
            if (/(?:Retrieved|Accessed|Available)\s+(?:from|at|on)?\s*:?\s*https?:\/\//i.test(ref)) {
                return 'acm-web';
            }

            // PRIORITY 2: Standard ACM Format (Conference/Journal)
            // Pattern: [...] Authors. Year. Title. In Proceedings...
            // Key Differentiator: "In Proceedings", "In Journal", or strict "Author. Year." structure
            if (/In\s+Proceedings\s+of|In\s+[A-Z].*?\d{4}/.test(ref)) {
                return 'acm';
            }

            // PRIORITY 3: IEEE Format
            // Note: We only check this if it didn't match Proceedings above
            if (/"[^"]{10,},?"/.test(ref) || /\bvol\.\s*\d+|pp\.\s*\d+/i.test(ref)) {
                return 'ieee';
            }

            // Fallback for ACM: Strictly checks for "Author. Year." (Note the dots)
            // Differentiates from APA "(Year)" and IEEE "Title,"
            if (/^\s*\[?\d+\]?\s+.*?[a-z]\.\s*\d{4}\.\s*[A-Z]/.test(ref)) {
                return 'acm';
            }

            // PRIORITY 4: Vancouver Format
            // Pattern: Journal; Year; Vol(Issue):Pages
            if (/[;:].*?\d{4}.*?[;:]/.test(ref)) {
                return 'vancouver';
            }

            return 'numbered-unknown';
        }

        // -----------------------------------------------------------
        // 2. TEXT-BASED REFERENCES (APA, Harvard, Chicago, etc.)
        // -----------------------------------------------------------

        // APA/Harvard: Author (Year)
        if (/\(\d{4}[a-z]?\)/.test(ref)) {
            // Harvard often uses: Author (Year) "Title" or Author (Year) Title
            // APA often uses: Author (Year). Title
            if (/^[A-Z][a-zA-Z'-]+.*?\(\d{4}\)/.test(ref)) {
                return 'apa'; // Mapping Harvard to APA logic often works best for parsing
            }
            if (/^[A-Z][a-zA-Z'-]+,\s*[A-Z]\.(?:\s*[A-Z]\.)*\s*\(\d{4}\)/.test(ref)) {
                return 'harvard';
            }
        }

        // MLA: "Title." (quoted title at end of citation usually)
        if (/"[^"]{5,}"\.?$/.test(ref) || /^[A-Z][a-zA-Z'-]+.*?\. "[^"]{5,}"/.test(ref)) {
            return 'mla';
        }

        // Chicago: Year.
        // Differentiator: Author. Year. Title. (Similar to ACM but no [number])
        if (/^[A-Z][a-zA-Z'-]+.*?\.\s*\d{4}\.\s/.test(ref)) {
            return 'chicago-author-date';
        }

        // Chicago (notes): First Last, Title (Place: Publisher, Year)
        if (/^[A-Z][a-zA-Z'-]+\s+[A-Z][a-zA-Z'-]+,\s*.+\([A-Z][a-z]+:\s*[^,]+,\s*\d{4}\)/.test(ref)) {
            return 'chicago-notes';
        }

        // Generic: has quoted title
        if (/"[^"]{10,}"/.test(ref)) {
            return 'quoted-title';
        }

        return 'unknown';
    }

    function extractDOI(text) {
        const doiPatterns = [
            // Full URL format: https://doi.org/10.xxxx/xxxxx
            /https?:\/\/(?:dx\.)?doi\.org\/(10\.\d{4,}[^\s,;)\]>"']+)/i,

            // DOI: prefix format
            /\bdoi:?\s*(10\.\d{4,}[^\s,;)\]>"']+)/i,

            // Bare DOI format (more restrictive)
            /(?:^|\s)(10\.\d{4,9}\/[^\s,;)\]>"']+)/
        ];

        for (const pattern of doiPatterns) {
            const match = text.match(pattern);
            if (match) {
                let doi = match[1];
                // Clean trailing punctuation
                doi = doi.replace(/[.,;:)\]>"']+$/, '');

                // Validate DOI structure
                if (/^10\.\d{4,}\/\S+$/.test(doi)) {
                    const remaining = text.replace(match[0], ' ').replace(/\s+/g, ' ').trim();
                    return {doi, remaining};
                }
            }
        }

        return {doi: '', remaining: text};
    }

    function extractURL(text) {
        // Match URLs but exclude DOI URLs
        const urlPattern = /(?:(?:Retrieved|Available|Accessed)\s+(?:from|at|on):?\s*)?(https?:\/\/(?!(?:dx\.)?doi\.org)[^\s)\]>"'<]+)/gi;
        const match = urlPattern.exec(text);

        if (match) {
            let url = match[1];
            // Clean trailing punctuation
            url = url.replace(/[.,;:)\]>"']+$/, '');

            // Basic URL validation
            if (/^https?:\/\/[^\s]+\.[^\s]+/.test(url)) {
                let remaining = text.replace(match[0], ' ');
                // Also remove access date patterns
                // Added (?:\s+(?:from|at|on))? to the end of these regex patterns
                remaining = remaining
                    .replace(/\.\s*Accessed:?\s*\d{1,2}\s+\w+\.?\s*\d{4}\.?(?:\s+(?:from|at|on))?/gi, '.')
                    .replace(/\.\s*Retrieved:?\s*\w+\.?\s*\d{1,2},?\s*\d{4}\.?(?:\s+(?:from|at|on))?/gi, '.')
                    .replace(/\s+/g, ' ')
                    .trim();

                return {url, remaining};
            }
        }

        return {url: '', remaining: text};
    }

    function extractYear(text, style) {
        const currentYear = new Date().getFullYear();
        let yearPatterns = [];

        switch (style) {
            case 'acm':
                // ACM: Year appears after authors with period: Authors. YYYY. Title
                yearPatterns = [
                    /\.\s*(\d{4})\.\s/,           // . YYYY. (between periods)
                ];
                break;

            case 'acm-web':
                // Web reference: [#] YYYY. Title. Retrieved...
                yearPatterns = [
                    /^\s*\[?\d+\]?\s+(\d{4})\./
                ];
                break;

            case 'apa':
            case 'harvard':
                yearPatterns = [
                    /\((\d{4}[a-z]?)\)/,
                    /\((\d{4}[a-z]?),\s*[^)]+\)/,
                    /\((n\.d\.)\)/i,
                    /\((in\s+press)\)/i
                ];
                break;

            case 'mla':
                yearPatterns = [
                    /,\s*(\d{4})\.?\s*$/,
                    /\b(\d{4})\.?\s*$/,
                    /,\s*(\d{4})[,.]/
                ];
                break;

            case 'chicago-author-date':
                yearPatterns = [
                    /\.\s*(\d{4}[a-z]?)\.\s/,
                    /\.\s*(\d{4}[a-z]?)\.?\s*$/
                ];
                break;

            case 'chicago-notes':
                yearPatterns = [
                    /,\s*(\d{4})\)\s*[.,]?\s*$/,
                    /\((?:[^)]+,\s*)?(\d{4})\)/
                ];
                break;

            case 'vancouver':
            case 'ieee':
                yearPatterns = [
                    /\.\s*(\d{4})\s*[A-Z][a-z]{2,8}\s*;/,
                    /\.\s*(\d{4})\s*;/,
                    /\[(\d{4})\]/,
                    /,\s*(\d{4})\.\s*$/
                ];
                break;

            default:
                yearPatterns = [
                    /\((\d{4}[a-z]?)\)/,
                    /\.\s*(\d{4})\.\s/,
                    /,\s*(\d{4})[,.);\s]/
                ];
        }

        // Fallback
        yearPatterns.push(/\b((?:19|20)\d{2})\b/);

        for (const pattern of yearPatterns) {
            const match = text.match(pattern);
            if (match) {
                const yearStr = match[1];

                if (/n\.d\./i.test(yearStr) || /in\s+press/i.test(yearStr)) {
                    const remaining = text.replace(match[0], ' ').replace(/\s+/g, ' ').trim();
                    return { year: yearStr.toLowerCase(), remaining };
                }

                const yearNum = parseInt(yearStr);

                if (yearNum >= 1800 && yearNum <= currentYear + 2) {
                    let remaining;

                    if (style === 'apa' || style === 'harvard') {
                        remaining = text.replace(/\(\d{4}[a-z]?(?:,\s*[^)]+)?\)/, ' ');
                    } else if (style === 'acm') {
                        // For ACM, DON'T remove the year pattern yet - author extraction needs it
                        return { year: yearStr, remaining: text };
                    } else if (style === 'acm-web') {
                        // For acm-web, remove "Year." pattern
                        remaining = text.replace(/\.\s*\d{4}\./, '.').replace(/^\s*\[?\d+\]?\s+\d{4}\./, '');
                    } else {
                        remaining = text.replace(match[0], ' ');
                    }

                    remaining = remaining.replace(/\s+/g, ' ').trim();
                    return { year: yearStr, remaining };
                }
            }
        }

        return { year: '', remaining: text };
    }

    function extractAuthors(text, style) {
        // Remove leading reference numbers
        let cleanText = text.replace(/^\s*\[?\d+\]?\s*/, '').trim();

        // DEFINITION: A surname can be one word ("Jane") or multiple ("John Doe")
        const surnamePattern = "(?:[A-Z][a-zA-Z'-]+(?:\\s+[A-Z][a-zA-Z'-]+)*)";

        const stylePatterns = {
            'acm': [
                // Removed lookahead (?=). Now consumes the year so it is removed from 'remaining'
                // Old: /^([\s\S]+?)\.\s*(?=\d{4}\.)/
                /^([\s\S]+?)\.\s*\d{4}\./,

                // Same here. Consumes the year.
                // Old: /^([\s\S]+?)\s*(?=\.?\s*\d{4}\.)/
                /^([\s\S]+?)\s*\.?\s*\d{4}\./
            ],

            'acm-web': [
                // ACM web references typically have no authors, just: [#] Year. Title. Retrieved...
                // Return a pattern that matches nothing valid, so we skip to title extraction
            ],

            'ieee': [
                // Initials First
                /^((?:[A-Z]\.\s*)+[A-Z][a-zA-Z'-]+(?:\s*,\s*(?:[A-Z]\.\s*)+[A-Z][a-zA-Z'-]+)*(?:\s*,?\s*and\s+(?:[A-Z]\.\s*)+[A-Z][a-zA-Z'-]+)?)\s*,/,
                // Full names in IEEE (First Last, First Last...)
                /^([A-Z][a-zA-Z'-]+\s+[A-Z][a-zA-Z'-]+(?:,\s*[A-Z][a-zA-Z'-]+\s+[A-Z][a-zA-Z'-]+)*(?:,?\s*(?:and|&)\s+[A-Z][a-zA-Z'-]+\s+[A-Z][a-zA-Z'-]+)?)(?:,|\.)/
            ],

            'apa': [
                // Uses surnamePattern to allow multiple surnames
                new RegExp(`^((?:${surnamePattern},\\s*(?:[A-Z]\\.\\s*)+)(?:,\\s*(?:${surnamePattern},\\s*(?:[A-Z]\\.\\s*)+))*(?:,?\\s*(?:&|and)\\s*${surnamePattern},\\s*(?:[A-Z]\\.\\s*)+)?)`),
                // Et al variations
                new RegExp(`^(${surnamePattern},\\s*(?:[A-Z]\\.\\s*)+et\\s+al\\.?)`, 'i'),
                // Single author
                new RegExp(`^(${surnamePattern},\\s*(?:[A-Z]\\.\\s*)+)`),
                // Organizations
                /^([A-Z][A-Za-z\s]+(?:Organization|Association|Institute|University|Foundation|Society|Agency|Committee|Corporation|Company))/i
            ],

            'harvard': [
                new RegExp(`^((?:${surnamePattern},\\s*(?:[A-Z]\\.)+)(?:\\s*,\\s*${surnamePattern},\\s*(?:[A-Z]\\.)+)*(?:\\s*(?:&|and)\\s*${surnamePattern},\\s*(?:[A-Z]\\.)+)?)`),
                new RegExp(`^(${surnamePattern},\\s*(?:[A-Z]\\.)+\\s*et\\s+al\\.?)`, 'i'),
                new RegExp(`^(${surnamePattern},\\s*(?:[A-Z]\\.)+)`)
            ],

            'mla': [
                new RegExp(`^(${surnamePattern},\\s*${surnamePattern}(?:\\s+[A-Z]\\.)?(?:,\\s*and\s+${surnamePattern}\\s+${surnamePattern})?)\\.`),
                new RegExp(`^(${surnamePattern},\\s*${surnamePattern}(?:\\s+${surnamePattern})?)\\.`),
                new RegExp(`^(${surnamePattern},\\s*${surnamePattern},?\\s*et\\s+al\\.?)`, 'i')
            ],

            'chicago-author-date': [
                new RegExp(`^(${surnamePattern},\\s*${surnamePattern}(?:,\\s*and\\s+${surnamePattern}\\s+${surnamePattern})?)\\.\\s*\\d{4}`),
                new RegExp(`^(${surnamePattern},\\s*${surnamePattern})\\.\\s*\\d{4}`)
            ],

            'chicago-notes': [
                new RegExp(`^(${surnamePattern}\\s+${surnamePattern}(?:\\s+and\\s+${surnamePattern}\\s+${surnamePattern})?)\\s*,`),
                new RegExp(`^(${surnamePattern}\\s+${surnamePattern})\\s*,`)
            ],

            'vancouver': [
                new RegExp(`^((?:${surnamePattern}\\s+[A-Z]{1,4})(?:\\s*,\\s*${surnamePattern}\\s+[A-Z]{1,4})*(?:\\s*,?\\s*et\\s+al\\.?)?)\\.`, 'i'),
                new RegExp(`^((?:${surnamePattern}\\s+[A-Z]{1,4})(?:\\s*,\\s*${surnamePattern}\\s+[A-Z]{1,4})*)\\.`)
            ],
        };

        // Safety Fallback for ACM/Numbered
        if ((style === 'acm' || style === 'numbered-unknown') && cleanText.match(/\d{4}\./)) {
             const yearMatch = cleanText.match(/\.?\s*(\d{4})\./);
             if (yearMatch && yearMatch.index > 5) {
                 const authors = cleanText.substring(0, yearMatch.index).trim().replace(/[.,]$/, '');
                 const remaining = cleanText.substring(yearMatch.index + yearMatch[0].length).trim();
                 return { authors, remaining };
             }
        }

        const genericPatterns = [
            // FirstName LastName, FirstName LastName, and FirstName LastName.
            /^((?:[A-Z][a-z]+(?:\s+[A-Z]\.?)?\s+[A-Z][a-zA-Z'-]+)(?:\s*,\s*(?:[A-Z][a-z]+(?:\s+[A-Z]\.?)?\s+[A-Z][a-zA-Z'-]+))*(?:\s*,?\s*and\s+[A-Z][a-z]+(?:\s+[A-Z]\.?)?\s+[A-Z][a-zA-Z'-]+)?)\./,
            // LastName, F. format
            /^((?:[A-Z][a-zA-Z'-]+(?:,\s*[A-Z]\.(?:\s*[A-Z]\.)*)?(?:\s*,\s*)?)+(?:(?:&|and)\s+[A-Z][a-zA-Z'-]+(?:,\s*[A-Z]\.(?:\s*[A-Z]\.)*)?)?)/,
            // et al. variations
            /^([A-Z][a-zA-Z'-]+(?:,?\s*[A-Z]\.(?:\s*[A-Z]\.)?)?(?:\s*,?\s*|\s+)et\s+al\.?)/i,
            // Simple First Last
            /^([A-Z][a-zA-Z'-]+\s+[A-Z][a-zA-Z'-]+(?:\s*(?:,|and)\s+[A-Z][a-zA-Z'-]+\s+[A-Z][a-zA-Z'-]+)*)/
        ];

        const patterns = stylePatterns[style] || genericPatterns;

        for (const pattern of patterns) {
            const match = cleanText.match(pattern);
            if (match && match[1]) {
                let authors = match[1].trim().replace(/[.,;:]+$/, '');

                if (authors.length >= 2 && authors.length <= 500 && /[A-Za-z]{2,}/.test(authors)) {
                    // Since the regex now includes the year in match[0],
                    // match[0].length automatically accounts for it.
                    // The slicing here correctly removes authors AND year.
                    const remaining = cleanText.slice(match[0].length).replace(/^[.,;:\s]+/, '').trim();
                    return { authors, remaining };
                }
            }
        }

        // Try generic patterns if style-specific ones failed
        if (stylePatterns[style] && stylePatterns[style].length > 0) {
            for (const pattern of genericPatterns) {
                const match = cleanText.match(pattern);
                if (match && match[1]) {
                    let authors = match[1].trim().replace(/[.,;:]+$/, '');
                    if (authors.length >= 2 && authors.length <= 500 && /[A-Za-z]{2,}/.test(authors)) {
                        const remaining = cleanText.slice(match[0].length).replace(/^[.,;:\s]+/, '').trim();
                        return { authors, remaining };
                    }
                }
            }
        }

        return { authors: '', remaining: cleanText };
    }

    function extractTitle(text, style) {
        // First, try quoted titles
        const quotedPatterns = [
            /"([^"]{5,})"/,
            /"([^"]{5,})"/,
            /'([^']{5,})'/,
            /Â«([^Â»]{5,})Â»/,
            /ã€Œ([^ã€]{5,})ã€/
        ];

        for (const pattern of quotedPatterns) {
            const match = text.match(pattern);
            if (match) {
                return {
                    title: match[1].trim(),
                    remaining: text.replace(match[0], ' ').replace(/\s+/g, ' ').trim()
                };
            }
        }

        let match;

        switch (style) {
            case 'acm':
                // ACM: Title. In Proceedings of... OR Title. Journal Name
                match = text.match(/^([^.]+(?:\?|!)?)\.\s*(?=In\s|[A-Z][a-z]+\s+[A-Z]|\d+,\s*\d+|$)/);
                if (match && match[1].length > 5) {
                    return {
                        title: match[1].trim(),
                        remaining: text.slice(match[0].length).trim()
                    };
                }
                // Fallback: everything before "In Proceedings"
                match = text.match(/^(.+?)\.\s*In\s+Proceedings/i);
                if (match && match[1].length > 5) {
                    return {
                        title: match[1].trim(),
                        remaining: text.slice(match[1].length + 1).trim()
                    };
                }
                break;

           case 'acm-web':
                // After removing [#] and year, the text starts with title
                // Title ends at "Retrieved" or "Accessed"
                match = text.match(/^(.+?)\.\s*(?:Retrieved|Accessed)/i);
                if (match && match[1].length > 3) {
                    return {
                        title: match[1].trim(),
                        remaining: text.slice(match[0].length - 9).trim()
                    };
                }
                // Fallback: everything before the URL
                match = text.match(/^(.+?)\.\s*(?=https?:\/\/)/i);
                if (match && match[1].length > 3) {
                    return {
                        title: match[1].trim(),
                        remaining: text.slice(match[0].length).trim()
                    };
                }
                break;

            case 'apa':
            case 'harvard':
                match = text.match(/^(.+?[^A-Z])\.\s*(?=[A-Z][a-z]+(?:\s+[A-Za-z]+)*\s*,?\s*\d|In\s+[A-Z]|$)/);
                if (match && match[1].length > 10) {
                    return {
                        title: match[1].trim(),
                        remaining: text.slice(match[0].length).trim()
                    };
                }
                break;

            case 'chicago-notes':
                match = text.match(/^(.+?)\s*\([A-Z][a-z]+:/);
                if (match && match[1].length > 5) {
                    return {
                        title: match[1].replace(/[,;:\s]+$/, '').trim(),
                        remaining: text.slice(match[1].length).trim()
                    };
                }
                break;

            case 'chicago-author-date':
                match = text.match(/^(.+?)\.\s*(?=[A-Z][a-z]+\s)/);
                if (match && match[1].length > 10) {
                    return {
                        title: match[1].trim(),
                        remaining: text.slice(match[0].length).trim()
                    };
                }
                break;

            case 'vancouver':
            case 'ieee':
                match = text.match(/^(.+?[.?!])\s*(?=[A-Z][a-z]*[A-Z]|[A-Z]{2,}\s|\d|$)/);
                if (match && match[1].length > 10) {
                    return {
                        title: match[1].replace(/\.$/, '').trim(),
                        remaining: text.slice(match[0].length).trim()
                    };
                }
                break;
        }

        // Generic patterns
        const genericPatterns = [
            /^(.+?[?!])\s+/,
            /^(.+?)\.\s*In[:\s]/i,
            /^(.+?)\.\s*\d+\s*\(/,
            /^(.{15,}?[^A-Z])\.\s+(?=[A-Z])/
        ];

        for (const pattern of genericPatterns) {
            match = text.match(pattern);
            if (match && match[1].length > 10) {
                return {
                    title: match[1].replace(/[.,;:]+$/, '').trim(),
                    remaining: text.slice(match[0].length).trim()
                };
            }
        }

        // Last resort
        const segments = text.split(/(?<=[.?!])\s+/);
        for (const segment of segments) {
            if (segment.length > 15 && /[a-z]{3,}/.test(segment)) {
                return {
                    title: segment.replace(/[.,;:]+$/, '').trim(),
                    remaining: text.replace(segment, '').replace(/^\s*[.,;:]\s*/, '').trim()
                };
            }
        }

        return { title: '', remaining: text };
    }

    function validateResults(result) {
        const currentYear = new Date().getFullYear();

        // console.log(result);

        // Title validation
        if (!result.title) {
            result.warnings.push('Title could not be extracted');
        } else if (result.title.length < 5) {
            result.warnings.push('Extracted title may be too short');
        } else if (result.title.length > 500) {
            result.warnings.push('Extracted title may be too long');
        }

        // Author validation
        if (!result.authors) {
            result.warnings.push('Authors could not be extracted');
        } else if (!/[A-Z]/.test(result.authors)) {
            result.warnings.push('Author format may be invalid');
        }

        // Year validation
        if (!result.year) {
            result.warnings.push('Publication year could not be extracted');
        } else if (!/^(n\.d\.|in\s+press)$/i.test(result.year)) {
            const yearNum = parseInt(result.year);
            if (isNaN(yearNum) || yearNum < 1800 || yearNum > currentYear + 2) {
                result.warnings.push('Extracted year may be invalid');
            }
        }

        // DOI validation
        if (result.doi && !/^10\.\d{4,}\/\S+$/.test(result.doi)) {
            result.warnings.push('DOI format may be invalid');
        }

        // URL validation
        if (result.url && !/^https?:\/\/[^\s]+\.[^\s]+/.test(result.url)) {
            result.warnings.push('URL format may be invalid');
        }

        // Cross-field validation
        if (!result.doi && !result.url) {
            result.warnings.push('No DOI or URL found - verification may require manual lookup');
        }
    }

    function cleanAllFields(result) {
        const fieldsToClean = ['title', 'authors', 'doi', 'url'];

        for (const field of fieldsToClean) {
            if (result[field]) {
                result[field] = result[field]
                    .replace(/\s+/g, ' ')
                    .replace(/^[.,;:\s"']+|[.,;:\s"']+$/g, '')
                    .trim();
            }
        }
    }

    // Export for Node.js/module usage
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = {extractReferenceInfo};
    }

    // Parse references from input - handles multiple formats
    function parseReferences(text) {
        const references = [];

        if (!text || typeof text !== 'string') {
            return references;
        }

        // Normalize line endings and clean up
        text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').trim();

        // Detect the reference format
        const format = detectReferenceFormat(text);

        switch (format) {
            case 'bracketed':      // [1], [2], etc.
                return parseBracketedFormat(text);
            case 'dotted':         // 1., 2., etc.
                return parseDottedFormat(text);
            case 'parenthetical':  // (1), (2), etc. or 1), 2), etc.
                return parseParentheticalFormat(text);
            case 'line-per-ref':   // Each line is a reference
                return parseLinePerRef(text);
            case 'blank-separated': // References separated by blank lines
            default:
                return parseBlankSeparated(text);
        }
    }

    // Detect what format the references are in
    function detectReferenceFormat(text) {
        const lines = text.split('\n').filter(l => l.trim().length > 0);

        // Count occurrences of different patterns
        const bracketedMatches = text.match(/\[\d+\]/g) || [];
        const dottedMatches = text.match(/^\s*\d{1,3}\.\s+[A-Z]/gm) || [];
        const parenMatches = text.match(/^\s*\(?\d{1,3}\)\s+[A-Z]/gm) || [];

        // Check for bracketed format [1], [2], etc.
        if (bracketedMatches.length >= 2) {
            // Verify these are at the start of references, not citations within text
            const atLineStart = (text.match(/^\s*\[\d+\]/gm) || []).length;
            const afterNewline = (text.match(/\n\s*\[\d+\]/g) || []).length;
            if (atLineStart + afterNewline >= bracketedMatches.length * 0.5) {
                return 'bracketed';
            }
        }

        // Check for dotted format: 1., 2., etc.
        if (dottedMatches.length >= 2) {
            return 'dotted';
        }

        // Check for parenthetical format: (1), 1), etc.
        if (parenMatches.length >= 2) {
            return 'parenthetical';
        }

        // Check if each line looks like a complete reference
        if (lines.length >= 2) {
            const looksLikeRefs = lines.filter(line => {
                const trimmed = line.trim();
                return (
                    trimmed.length > 40 &&
                    /^[A-Z]/.test(trimmed) &&
                    // Contains year-like pattern
                    /\b(19|20)\d{2}\b/.test(trimmed) &&
                    // Contains author-like pattern (name with comma or period)
                    /[A-Z][a-z]+[,.]/.test(trimmed)
                );
            });

            if (looksLikeRefs.length >= lines.length * 0.6) {
                return 'line-per-ref';
            }
        }

        // Check for blank-line separation
        const blankLineCount = (text.match(/\n\s*\n/g) || []).length;
        if (blankLineCount >= 1 && lines.length > blankLineCount) {
            return 'blank-separated';
        }

        // Default to line-per-ref if we have multiple lines
        if (lines.length >= 2) {
            return 'line-per-ref';
        }

        return 'blank-separated';
    }

    // Parse [1], [2], etc. format
    function parseBracketedFormat(text) {
        const references = [];
        const parts = text.split(/(\[\d+\])/);
        let currentRef = '';
        let currentNum = null;

        for (let i = 0; i < parts.length; i++) {
            const part = parts[i].trim();
            if (/^\[\d+\]$/.test(part)) {
                if (currentRef && currentNum !== null) {
                    references.push({
                        number: currentNum,
                        text: cleanReferenceText(currentRef)
                    });
                }
                currentNum = parseInt(part.match(/\d+/)[0]);
                currentRef = '';
            } else if (part.length > 0) {
                currentRef += (currentRef ? ' ' : '') + part;
            }
        }

        if (currentRef && currentNum !== null) {
            references.push({
                number: currentNum,
                text: cleanReferenceText(currentRef)
            });
        }

        return references
            .map(r => `[${r.number}] ${r.text}`)
            .filter(r => r.length > 0);
    }

    // Parse 1., 2., etc. format
    function parseDottedFormat(text) {
        const references = [];
        // Matches "1." at start of line or string
        const pattern = /(?:^|\n)\s*(\d{1,3})\.\s+/g;
        const matches = [...text.matchAll(pattern)];

        if (matches.length === 0) {
            return [cleanReferenceText(text)];
        }

        for (let i = 0; i < matches.length; i++) {
            const startIndex = matches[i].index + matches[i][0].length;
            // The end of this ref is the start of the next match (or end of text)
            const endIndex = matches[i + 1] ? matches[i + 1].index : text.length;

            const refText = text.slice(startIndex, endIndex).trim();
            if (refText.length > 0) {
                references.push({
                    number: parseInt(matches[i][1]),
                    text: cleanReferenceText(refText)
                });
            }
        }

        return references
            .map(r => `${r.number}. ${r.text}`)
            .filter(r => r.length > 0);
    }

    // Parse (1), 1), etc. format
    function parseParentheticalFormat(text) {
        const references = [];
        const pattern = /(?:^|\n)\s*\(?(\d{1,3})\)\s+/g;
        const matches = [...text.matchAll(pattern)];

        if (matches.length === 0) {
            return [cleanReferenceText(text)];
        }

        for (let i = 0; i < matches.length; i++) {
            const startIndex = matches[i].index + matches[i][0].length;
            const endIndex = matches[i + 1] ? matches[i + 1].index : text.length;

            const refText = text.slice(startIndex, endIndex).trim();
            if (refText.length > 0) {
                references.push({
                    number: parseInt(matches[i][1]),
                    text: cleanReferenceText(refText)
                });
            }
        }

        return references
            .map(r => `(${r.number}) ${r.text}`)
            .filter(r => r.length > 0);
    }

    // Parse line-per-reference format
    function parseLinePerRef(text) {
        return text
            .split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0)
            .map(line => cleanReferenceText(line))
            .filter(ref => ref.length > 10); // Filter out very short lines
    }

    // Parse blank-line-separated format
    function parseBlankSeparated(text) {
        const references = [];
        let currentRef = '';

        const lines = text.split('\n');

        for (const line of lines) {
            const trimmedLine = line.trim();

            if (trimmedLine === '') {
                // Blank line - end of current reference
                if (currentRef.trim().length > 0) {
                    references.push(cleanReferenceText(currentRef));
                    currentRef = '';
                }
            } else {
                // Continue building current reference
                currentRef += (currentRef ? ' ' : '') + trimmedLine;
            }
        }

        // Don't forget the last reference
        if (currentRef.trim().length > 0) {
            references.push(cleanReferenceText(currentRef));
        }

        return references.filter(ref => ref.length > 10);
    }

    // Clean up reference text
    function cleanReferenceText(text) {
        return text
            .replace(/\n+/g, ' ')      // Replace newlines with spaces
            .replace(/\s+/g, ' ')       // Collapse multiple spaces
            .replace(/^\s*[â€¢\-â€“â€”]\s*/, '') // Remove leading bullets
            .trim();
    }

    // Create Google Scholar search URL
    function getGoogleScholarUrl(title) {
        if (!title) return '';
        const query = encodeURIComponent(title);
        return `${GOOGLE_SCHOLAR_API}${query}`;
    }

    // Display results in table
    function displayResults(extractedRefs) {
        if (extractedRefs.length === 0) {
            ui.resultsContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 40px 20px;">No references found to process.</div>';
            ui.exportButton.style.display = 'none';
            return;
        }

        let html = `
        <table>
            <thead>
                <tr>
                    <th class="checkbox-cell"><input type="checkbox" id="selectAll"></th>
                    <th>#</th>
                    <th>Title</th>
                    <th>Authors</th>
                    <th>DOI/URL</th>
                    <th>Google Scholar</th>
                    <th>Auto Verification</th>
                </tr>
            </thead>
            <tbody>
    `;

        extractedRefs.forEach((ref, index) => {
            const status = ref.warnings.length === 0 ? 'verified' :
                (!ref.title || !ref.authors) ? 'error' : 'warning';
            const statusClass = `status-${status}`;

            const extractionBadge = ref.extractionMethod === 'llm'
                ? '<span class="extraction-badge badge-llm">LLM</span>'
                : '<span class="extraction-badge badge-local">Local</span>';

            const doiUrlDisplay = ref.doi
                ? `<a href="https://doi.org/${ref.doi}" target="_blank" class="link-button">DOI</a>`
                : ref.url
                    ? `<a href="${ref.url}" target="_blank" class="link-button">URL</a>`
                    : 'â€”';

            const scholarUrl = getGoogleScholarUrl(ref.title);
            const scholarLink = scholarUrl
                ? `<a href="${scholarUrl}" target="_blank" class="link-button">Search</a>`
                : 'â€”';

            // Verification feedback
            let feedbackHtml = '<span class="feedback-cell">Verifying...</span>';
            if (ref.verification) {
                const feedbackClass = ref.verification.verified ? 'feedback-verified' :
                    !ref.verification.authorMatch ? 'feedback-error' :
                        'feedback-warning';

                let icon = 'âœ“';
                if (!ref.verification.verified) icon = 'âœ—';
                else if (!ref.verification.authorMatch) icon = 'âš ';

                feedbackHtml = `<span class="feedback-cell ${feedbackClass}">${icon} ${ref.verification.message}</span>`;
            }

            html += `
            <tr>
                <td class="checkbox-cell"><input type="checkbox" class="row-checkbox" data-index="${index}"></td>
                <td>${index + 1}</td>
                <td class="${statusClass}">${ref.title || '<em>Not extracted</em>'}${extractionBadge}</td>
                <td>${ref.authors || '<em>Not extracted</em>'}</td>
                <td>${doiUrlDisplay}</td>
                <td>${scholarLink}</td>
                <td id="feedback-${index}">${feedbackHtml}</td>
            </tr>
        `;

            if (ref.warnings.length > 0) {
                html += `
                <tr>
                    <td colspan="7" style="background-color: #fff3cd; padding: 8px; font-size: 0.85rem;">
                        âš ï¸ ${ref.warnings.join(', ')}
                    </td>
                </tr>
            `;
            }
        });

        html += `
            </tbody>
        </table>
    `;

        ui.resultsContainer.innerHTML = html;
        ui.exportButton.style.display = 'block';

        // Setup select all checkbox
        document.getElementById('selectAll').addEventListener('change', (e) => {
            document.querySelectorAll('.row-checkbox').forEach(cb => {
                cb.checked = e.target.checked;
            });
        });

        // Store extracted references for export
        window.extractedReferences = extractedRefs;
    }

    // Update verification feedback in table
    function updateVerificationFeedback(index, verification) {
        const feedbackCell = document.getElementById(`feedback-${index}`);
        if (!feedbackCell) return;

        // Determine status and styling
        let status = 'unverified';
        let icon = 'âœ—';
        let feedbackClass = 'feedback-error';

        if (verification.verified) {
            if (verification.confidence === 'high') {
                status = 'verified';
                icon = 'âœ“';
                feedbackClass = 'feedback-verified';
            } else if (verification.confidence === 'medium') {
                status = 'partial';
                icon = 'âš ';
                feedbackClass = 'feedback-warning';
            } else {
                status = 'low-confidence';
                icon = 'âš ';
                feedbackClass = 'feedback-warning';
            }

            // Override if author mismatch
            if (verification.authorMatch === false) {
                icon = 'âš ';
                feedbackClass = 'feedback-warning';
                status = 'author-mismatch';
            }

            // Override if year mismatch
            if (verification.yearMatch === false) {
                icon = 'âš ';
                feedbackClass = 'feedback-warning';
                status = 'year-mismatch';
            }
        }

        // Build the feedback HTML
        let feedbackHTML = `<div class="verification-result ${feedbackClass}">`;

        // Main status line with icon and message
        feedbackHTML += `
            <div class="verification-status">
                <span class="status-icon">${icon}</span>
                <span class="status-message">${verification.message}</span>
            </div>
        `;

        // Add source badge
        if (verification.source) {
            const sourceClass = getSourceBadgeClass(verification.source);
            feedbackHTML += `
                <div class="verification-source">
                    <span class="source-badge ${sourceClass}">${verification.source}</span>
                </div>
            `;
        }

        // Add confidence indicator for verified results
        if (verification.verified && verification.confidence) {
            const confidenceClass = `confidence-${verification.confidence}`;
            const confidenceText = verification.confidence.charAt(0).toUpperCase() + verification.confidence.slice(1);
            feedbackHTML += `
                <div class="verification-confidence">
                    <span class="confidence-badge ${confidenceClass}">${confidenceText} Confidence</span>
                </div>
            `;
        }

        // Add detailed comparison if available
        if (verification.verified && (verification.foundTitle || verification.foundAuthors)) {
            feedbackHTML += `<div class="verification-details">`;

            if (verification.foundTitle) {
                feedbackHTML += `
                    <div class="detail-row">
                        <span class="detail-label">Found Title:</span>
                        <span class="detail-value">${escapeHtml(verification.foundTitle)}</span>
                    </div>
                `;
            }

            if (verification.foundAuthors) {
                const authorIcon = verification.authorMatch === false ? 'âš ' : 'âœ“';
                const authorClass = verification.authorMatch === false ? 'mismatch' : 'match';
                feedbackHTML += `
                    <div class="detail-row ${authorClass}">
                        <span class="detail-label">Found Authors:</span>
                        <span class="detail-value">${authorIcon} ${escapeHtml(verification.foundAuthors)}</span>
                    </div>
                `;
            }

            if (verification.canonicalUrl) {
                feedbackHTML += `
                    <div class="detail-row">
                        <span class="detail-label">Canonical URL:</span>
                        <a href="${escapeHtml(verification.canonicalUrl)}" target="_blank" rel="noopener noreferrer" class="canonical-link">
                            ${truncateUrl(verification.canonicalUrl)}
                            <span class="external-icon">â†—</span>
                        </a>
                    </div>
                `;
            }

            feedbackHTML += `</div>`;
        }

        // Add warnings if present
        if (verification.warning) {
            feedbackHTML += `
                <div class="verification-warning">
                    ${verification.warning}
                </div>
            `;
        }

        // Add cache indicator
        if (verification.fromCache) {
            feedbackHTML += `
                <div class="cache-indicator">
                    <span class="cache-badge">ðŸ“¦ Cached</span>
                </div>
            `;
        }

        // Add manual verification link for unverified or low-confidence results
        if (!verification.verified || verification.confidence === 'low') {
            if (verification.url) {
                feedbackHTML += `
                    <div class="manual-verification">
                        <a href="${escapeHtml(verification.url)}" target="_blank" rel="noopener noreferrer" class="manual-link">
                            ðŸ” Search on Google Scholar
                        </a>
                    </div>
                `;
            }
        }

        feedbackHTML += `</div>`;

        feedbackCell.innerHTML = feedbackHTML;
    }

    // Helper function to get source badge class
    function getSourceBadgeClass(source) {
        const sourceMap = {
            'DOI': 'source-doi',
            'DOI + CrossRef': 'source-doi',
            'DOI.org': 'source-doi',
            'CrossRef': 'source-crossref',
            'CrossRef DOI': 'source-crossref',
            'Semantic Scholar': 'source-semantic',
            'OpenAlex': 'source-openalex',
            'Google Scholar': 'source-google',
            'LLM (Gemini)': 'source-llm',
            'LLM': 'source-llm'
        };
        return sourceMap[source] || 'source-default';
    }

    // Helper function to escape HTML
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Helper function to truncate long URLs
    function truncateUrl(url, maxLength = 50) {
        if (url.length <= maxLength) return url;

        try {
            const urlObj = new URL(url);
            const domain = urlObj.hostname;
            const path = urlObj.pathname + urlObj.search;

            if (path.length > maxLength - domain.length - 10) {
                return domain + path.substring(0, maxLength - domain.length - 13) + '...';
            }
            return domain + path;
        } catch {
            return url.substring(0, maxLength - 3) + '...';
        }
    }

    // Export selected references to CSV
    function exportToCSV() {
        const selectedRefs = [];
        const checkboxes = document.querySelectorAll('.row-checkbox:checked');

        checkboxes.forEach(cb => {
            const index = parseInt(cb.dataset.index);
            const ref = window.extractedReferences[index];

            selectedRefs.push(ref);
        });

        if (selectedRefs.length === 0) {
            alert('Please select at least one reference to export.');
            return;
        }

        // Create CSV content
        const headers = ['Title', 'Authors', 'Year', 'DOI', 'URL', 'Extraction Method', 'Verified', 'Verification Message', 'Warnings'];
        const csvRows = [headers.join(',')];

        selectedRefs.forEach(ref => {
            const verified = ref.verification ? (ref.verification.verified ? 'Yes' : 'No') : 'N/A';
            const verificationMsg = ref.verification ? ref.verification.message : '';

            const row = [
                `"${ref.title.replace(/"/g, '""')}"`,
                `"${ref.authors.replace(/"/g, '""')}"`,
                `"${ref.year}"`,
                `"${ref.doi}"`,
                `"${ref.url}"`,
                `"${ref.extractionMethod}"`,
                `"${verified}"`,
                `"${verificationMsg.replace(/"/g, '""')}"`,
                `"${ref.warnings.join('; ').replace(/"/g, '""')}"`
            ];
            csvRows.push(row.join(','));
        });

        const csvContent = csvRows.join('\n');
        const blob = new Blob([csvContent], {type: 'text/csv;charset=utf-8;'});
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'references_export.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }


    // Calculate Levenshtein distance and similarity
    function levenshteinDistance(str1, str2) {
        const matrix = Array(str2.length + 1).fill(null).map(() => []);
        for (let i = 0; i <= str2.length; i++) matrix[i][0] = i;
        for (let j = 0; j <= str1.length; j++) matrix[0][j] = j;

        for (let i = 1; i <= str2.length; i++) {
            for (let j = 1; j <= str1.length; j++) {
                const cost = str2[i - 1] === str1[j - 1] ? 0 : 1;
                matrix[i][j] = Math.min(
                    matrix[i - 1][j] + 1,
                    matrix[i][j - 1] + 1,
                    matrix[i - 1][j - 1] + cost
                );
            }
        }
        return matrix[str2.length][str1.length];
    }

    function calculateSimilarity(str1, str2) {
        if (!str1 || !str2) return 0;

        const longer = str1.length > str2.length ? str1 : str2;
        const shorter = str1.length > str2.length ? str2 : str1;

        if (longer.length === 0) {
            console.warn(`Similarity checking: [${longer}] is empty`);
            return 1.0;
        }

        const editDistance = levenshteinDistance(longer, shorter);
        const score =  (longer.length - editDistance) / longer.length;
        // console.debug(`Similarity: ${score}, [${longer}] vs [${shorter}]`);
        return score;
    }

    function getBigrams(str) {
        const bigrams = new Set();
        for (let i = 0; i < str.length - 1; i++) {
            bigrams.add(str.substring(i, i + 2));
        }
        return bigrams;
    }

    // Add this function to verify DOI directly
    async function verifyReferenceViaDOI(ref) {
        if (!ref.doi) {
            return {verified: false, message: 'No DOI provided'};
        }

        try {
            // Normalize DOI
            const doi = ref.doi.replace(/^(https?:\/\/)?(dx\.)?doi\.org\//, '');

            // Try DOI.org resolution first
            const doiUrl = `https://doi.org/${doi}`;
            const response = await fetch(doiUrl, {
                method: 'HEAD',
                redirect: 'manual' // Don't follow redirects
            });

            if (response.status === 302 || response.status === 301) {
                // DOI resolves successfully
                return {
                    verified: true,
                    confidence: 'high',
                    authorMatch: true, // Assume true since DOI is unique
                    message: 'âœ“ DOI resolves successfully',
                    canonicalUrl: doiUrl,
                    source: 'DOI.org'
                };
            }

            // Try CrossRef API as fallback
            const crossRefUrl = `https://api.crossref.org/works/${doi}`;
            const crossRefResponse = await fetch(crossRefUrl);

            if (crossRefResponse.ok) {
                const data = await crossRefResponse.json();
                const work = data.message;

                const titleSim = calculateSimilarity(
                    (ref.title || '').toLowerCase(),
                    (work.title?.[0] || '').toLowerCase()
                );

                return {
                    verified: true,
                    confidence: titleSim > 0.9 ? 'high' : (titleSim > 0.7 ? 'medium' : 'low'),
                    authorMatch: true,
                    message: 'âœ“ Verified DOI via CrossRef DOI lookup',
                    foundTitle: work.title?.[0] || '',
                    foundAuthors: work.author?.map(a => `${a.family}, ${a.given}`).join('; ') || '',
                    canonicalUrl: doiUrl,
                    source: 'CrossRef DOI'
                };
            }

            return {verified: false, message: 'DOI not found'};

        } catch (error) {
            console.error('DOI verification error:', error);
            return {verified: false, message: 'DOI verification failed'};
        }
    }

    // CrossRef API verification
    async function verifyReferenceViaCrossRef(ref) {
    try {
        const baseUrl = 'https://api.crossref.org/works';
        const headers = { 'User-Agent': 'AcademicReferenceVerifier/1.0 (mailto:nuwanj.nus@gmail.com)' };

        const getTitleQueryUrl = () => {
            if (!ref.title) return null;
            let q = `query.title=${encodeURIComponent(ref.title)}`;
            if (ref.authors) {
                const firstAuthor = ref.authors.split(',')[0].split(';')[0].trim();
                q += `&query.author=${encodeURIComponent(firstAuthor)}`;
            }
            if (ref.year) {
                q += `&filter=from-pub-date:${ref.year},until-pub-date:${ref.year}`;
            }
            return `${baseUrl}?${q}&rows=1&sort=relevance`;
        };

        let targetUrl = '';
        let isDirectDoiLookup = false;

        // Determine the starting URL
        if (ref.doi) {
            const cleanDoi = ref.doi.replace(/^(https?:\/\/)?(dx\.)?doi\.org\//, '');
            targetUrl = `${baseUrl}/${encodeURIComponent(cleanDoi)}`;
            isDirectDoiLookup = true;
        } else if (ref.title) {
            targetUrl = getTitleQueryUrl();
        } else {
            return { verified: false, message: 'Insufficient data for CrossRef search', source: 'CrossRef' };
        }

        let response = await fetch(targetUrl, { headers });

        // Fallback: If DOI lookup failed (404), switch URL to Title Query and retry
        if (!response.ok && isDirectDoiLookup && ref.title) {
            console.log('DOI lookup failed, switching to title search...');
            targetUrl = getTitleQueryUrl();
            isDirectDoiLookup = false; // We are no longer doing a direct lookup
            response = await fetch(targetUrl, { headers });
        }

        if (!response.ok) {
            // If it still fails after fallback, throw error
            throw new Error(`CrossRef API error: ${response.status}`);
        }

        const data = await response.json();

        // Normalize data: Direct DOI returns `data.message` (object), Query returns `data.message.items` (array)
        let work = isDirectDoiLookup ? data.message : (data.message.items?.[0]);

        if (!work) {
            return { verified: false, message: 'Not found in CrossRef', source: 'CrossRef' };
        }

        const foundTitle = work.title?.[0] || '';
        const titleSim = calculateSimilarity(
            (ref.title || '').toLowerCase(),
            foundTitle.toLowerCase()
        );

        // Strictness check for Search Results (not needed for Direct DOI which is exact)
        if (!isDirectDoiLookup && titleSim < 0.6) {
             return {
                verified: false,
                message: `Low title similarity (${Math.round(titleSim * 100)}%)`,
                source: 'CrossRef'
            };
        }

        const foundAuthors = work.author?.map(a =>
            `${a.family}${a.given ? ', ' + a.given : ''}`
        ).join('; ') || '';

        let authorMatch = true;
        if (ref.authors && foundAuthors) {
            const authorSim = calculateSimilarity(ref.authors.toLowerCase(), foundAuthors.toLowerCase());
            authorMatch = authorSim > 0.5;
        }

        const foundYear = work.published?.['date-parts']?.[0]?.[0];
        const yearMatch = !ref.year || !foundYear || Math.abs(parseInt(ref.year) - foundYear) <= 1;

        // Determine confidence
        let confidence = 'low';
        if (titleSim > 0.9){
            if (isDirectDoiLookup){
                confidence = 'high';
            } else if ( authorMatch && yearMatch)
            {
                confidence = 'high';
            }else{
                confidence = 'medium'
            }
        } else if (titleSim > 0.75 && (authorMatch || yearMatch)) {
            confidence = 'medium';
        }

        // Auto-fill DOI if missing
        if (work.DOI && !ref.doi) ref.doi = work.DOI;

        return {
            verified: true,
            confidence,
            authorMatch,
            yearMatch,
            foundTitle,
            foundAuthors,
            canonicalUrl: work.DOI ? `https://doi.org/${work.DOI}` : work.URL,
            message: confidence === 'high' ? 'âœ“ Verified via CrossRef' : `âš  Partial match (${Math.round(titleSim * 100)}%)`,
            source: 'CrossRef',
            score: work.score
        };

    } catch (error) {
        console.error('CrossRef verification error:', error);
        return { verified: false, message: `CrossRef error: ${error.message}`, source: 'CrossRef' };
    }
}

    // Verify reference using Semantic Scholar before LLM
    async function verifyReferenceViaSemanticScholar(ref) {
        const result = {
            verified: false,
            authorMatch: false,
            message: 'Verifying via Semantic Scholar...',
            confidence: 'low',
            source: 'Semantic Scholar'
        };

        if (!ref.title) {
            return result
        }

        try {
            const query = encodeURIComponent(ref.title);
            const response = await fetch(`https://api.semanticscholar.org/graph/v1/paper/search?query=${query}&limit=1&fields=title,authors,externalIds,url`);
            if (!response.ok) {
                result.message = 'Semantic Scholar API unavailable';
                return result;
            }

            const data = await response.json();
            if (!data.data || data.data.length === 0) {
                result.message = 'Not found in Semantic Scholar';
                return result;
            }

            // Check top 3 results for best match
            let bestMatch = null;
            let bestSimilarity = 0;

            for (const paper of data.data) {
                const titleSim = calculateSimilarity(
                    ref.title.toLowerCase(),
                    paper.title.toLowerCase()
                );

                if (titleSim > bestSimilarity) {
                    bestSimilarity = titleSim;
                    bestMatch = paper;
                }
            }

            if (bestSimilarity > 0.6 && bestMatch) {
                const authors = bestMatch.authors?.map(a => a.name).join(', ') || '';

                let authorMatch = true;
                if (ref.authors && authors) {
                    const authorSim = calculateSimilarity(
                        ref.authors.toLowerCase(),
                        authors.toLowerCase()
                    );
                    authorMatch = authorSim > 0.5;
                }

                result.verified = true;
                result.confidence = bestSimilarity > 0.9 ? 'high' : bestSimilarity > 0.75 ? 'medium' : 'low';
                result.authorMatch = authorMatch;
                result.foundTitle = bestMatch.title;
                result.foundAuthors = authors;
                result.canonicalUrl = bestMatch.externalIds?.DOI
                    ? `https://doi.org/${bestMatch.externalIds.DOI}`
                    : bestMatch.url;
                result.message = authorMatch
                    ? 'âœ“ Verified via Semantic Scholar'
                    : 'âš  Verified but author mismatch (Semantic Scholar)';

                // Enrich reference data
                if (bestMatch.externalIds?.DOI && !ref.doi) {
                    ref.doi = bestMatch.externalIds.DOI;
                }
                if (bestMatch.year && !ref.year) {
                    ref.year = bestMatch.year;
                }
            } else {
                result.message = 'âš  Low title similarity in Semantic Scholar';
            }
        } catch (err) {
            console.error('Semantic Scholar verification error:', err);
            result.message = 'Semantic Scholar verification failed';
        }

        return result;
    }

    async function verifyReferenceViaOpenAlex(ref) {
        try {
            const query = encodeURIComponent(ref.title);
            const url = `https://api.openalex.org/works?search=${query}&select=id,title,authorships,publication_year,doi,primary_location&mailto=nuwanj.nus@gmail.com`;

            const response = await fetch(url);
            if (!response.ok) {
                return {verified: false, message: 'OpenAlex API unavailable'};
            }

            const data = await response.json();
            if (!data.results || data.results.length === 0) {
                return {verified: false, message: 'Not found in OpenAlex'};
            }

            const work = data.results[0];
            const titleSim = calculateSimilarity(
                ref.title.toLowerCase(),
                work.title.toLowerCase()
            );

            if (titleSim > 0.6) {
                const authors = work.authorships
                    ?.map(a => a.author.display_name)
                    .join(', ') || '';

                const authorSim = ref.authors
                    ? calculateSimilarity(ref.authors.toLowerCase(), authors.toLowerCase())
                    : 1.0;

                return {
                    verified: true,
                    confidence: titleSim > 0.9 ? 'high' : 'medium',
                    authorMatch: authorSim > 0.5,
                    message: 'âœ“ Verified via OpenAlex',
                    foundTitle: work.title,
                    foundAuthors: authors,
                    canonicalUrl: work.doi || work.primary_location?.landing_page_url,
                    source: 'OpenAlex'
                };
            }

            return {verified: false, message: 'Low title similarity in OpenAlex'};

        } catch (error) {
            console.error('OpenAlex verification error:', error);
            return {verified: false, message: 'OpenAlex verification failed'};
        }
    }

    async function verifyReferenceViaGoogleScholar(reference) {
        try {
            // Construct search query from reference
            let searchQuery = reference.title || '';
            if (reference.authors && reference.authors.length > 0) {
                searchQuery += ' ' + reference.authors[0];
            }
            if (reference.year) {
                searchQuery += ' ' + reference.year;
            }

            const scholarUrl = getGoogleScholarUrl(searchQuery.trim());

            // Use CORS proxy
            const corsProxy = 'https://api.codetabs.com/v1/proxy?quest=';
            const searchUrl = corsProxy + encodeURIComponent(scholarUrl);

            // Try to fetch the page
            const response = await fetch(searchUrl, {
                headers: {
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                }
            });

            if (!response.ok) {
                throw new Error('Google Scholar request failed');
            }

            const html = await response.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');

            // Extract first result
            const firstResult = doc.querySelector('div.gs_ri');
            if (!firstResult) {
                return {verified: false, source: 'Google Scholar', error: 'No results found'};
            }

            // Extract title
            const titleElement = firstResult.querySelector('h3.gs_rt');
            const titleLink = titleElement?.querySelector('a');
            const title = titleLink?.textContent?.trim() || titleElement?.textContent?.trim() || '';

            // Extract authors and year from citation data
            const citationData = firstResult.querySelector('div.gs_a');
            const citationText = citationData?.textContent || '';

            const authors = citationText.split('-')[0]?.trim() || '';
            const yearMatch = citationText.match(/\b(19|20)\d{2}\b/);
            const year = yearMatch ? yearMatch[0] : '';

            // Extract URL
            const url = titleLink?.href || '';

            const titleSimilarity = calculateSimilarity(
                reference.title?.toLowerCase() || '',
                title.toLowerCase()
            );

            const verified = titleSimilarity > 0.6;

            const authorSimilarity = calculateSimilarity(
                reference.authors?.toLowerCase() || '',
                authors.toLowerCase()
            );

            const authorMatch = authorSimilarity > 0.6;
            const confidence = titleSimilarity > 0.9 ? 'high' : titleSimilarity > 0.7 ? 'medium' : 'low';

            return {
                verified,
                authorMatch,
                confidence,
                foundTitle: title,
                foundAuthors: authors,
                canonicalUrl: url,
                message: verified
                    ? `âš  Verified via Google Scholar (scraping - may be unreliable)`
                    : 'Not verified in Google Scholar',
                warning: 'âš  Google Scholar data may be unreliable due to HTML parsing. Use with caution.',
                source: 'Google Scholar'
            };

        } catch (error) {
            console.error('Google Scholar verification error:', error);
            return {
                verified: false,
                source: 'Google Scholar',
                message: error.message,
                warning: 'Failed to verify via Google Scholar'
            };
        }
    }

    // Verify reference using LLM
    async function verifyReferenceWithLLM(reference) {
        const apiKey = storage.get('geminiApiKey');
        const model = storage.get('geminiModel');

        const manualSearchUrl = getGoogleScholarUrl(reference.title)

        if (!apiKey || !model) {
            return {
                verified: false,
                message: 'API key not configured for verification',
                source: 'LLM',
                url: manualSearchUrl,
            };
        }

        console.debug('verifyReferenceWithLLM');

        const prompt = `You are a highly accurate academic reference verification assistant.

Your task is to determine whether a given reference corresponds to a real, published academic work (journal article, conference paper, book chapter, or preprint).

You MUST use your web search tool to perform verification. Do NOT rely on prior knowledge or assumptions.

REFERENCE TO VERIFY:
- Title: "${reference.title}"
- Authors: "${reference.authors}"
- Year: "${reference.year}"
- DOI: "${reference.doi}"
- URL: "${reference.url}"

VERIFICATION PROCEDURE (follow in order, do not skip steps):

1. SEARCH STRATEGY (in strict priority order):
   a. If a DOI is provided and non-empty, attempt to resolve the DOI directly.
   b. If DOI resolution fails or is missing, attempt to resolve the provided URL.
   c. If both fail or are missing, search by exact Title.
   d. If needed, refine the search using Title + first Author.
   e. Do NOT search by authors alone without the title.

2. EVIDENCE STANDARD:
   - Acceptable evidence includes publisher pages, journal websites, conference proceedings, DOI registries (e.g., Crossref), or reputable academic indexes.
   - Blogs, citation-only pages, or unverifiable mirrors are NOT sufficient evidence.

3. EXISTENCE DECISION:
   - If no credible evidence of a published work matching the title or DOI is found, set:
     - "exists": false
     - "confidence": "high"
     - Explain clearly why in "message".
   - If a work is found but the title clearly does NOT match the provided title, set:
     - "exists": false
     - "confidence": "high"

4. IF A MATCHING WORK IS FOUND:
   - Set "exists": true
   - Extract canonical metadata from the best available source.

5. COMPARISON RULES (only if exists = true):
   - foundTitle: Use the exact title from the source (case preserved).
   - foundAuthors: Use the author list as published (order preserved).
   - authorMatch:
     - true if authors substantially match (allow initials, abbreviations, reordered middle names, or "et al.").
     - false only if there is a clear mismatch (e.g., different first author or entirely different author set).
   - yearMatch:
     - true if the provided year matches the found publication year, allowing Â±1 year for preprint vs. final publication.
     - false otherwise.
   - canonicalUrl:
     - Prefer a DOI URL (https://doi.org/...) if available.
     - Otherwise, provide the most authoritative publisher or archive URL.
   - confidence:
     - "high": Title + authors clearly match (DOI match if provided).
     - "medium": Title matches but authors or year differ slightly.
     - "low": A similar paper was found, but identity is uncertain.
   - message:
     - Briefly explain how the paper was found and note any discrepancies.

STRICT OUTPUT REQUIREMENTS:
- Respond with ONLY valid JSON.
- No markdown, no explanations, no code blocks, no extra text.
- Start the response with { and end with }.
- All fields must be present exactly as specified.

OUTPUT FORMAT (exact keys and order required):
{
  "exists": true,
  "confidence": "high",
  "authorMatch": true,
  "yearMatch": true,
  "foundTitle": "...",
  "foundAuthors": "...",
  "canonicalUrl": "...",
  "message": "..."
}`;
        let jsonText = null;
        try {
            const response = await fetch(API_CONFIG.apiGenerateUrl(apiKey, model), {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    contents: [{
                        parts: [{text: prompt}]
                    }],
                    generationConfig: {
                        temperature: 0,  // Deterministic output
                        topK: 1,
                        topP: 1,
                        maxOutputTokens: 1024,
                        responseMimeType: "application/json",
                    }
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API error: ${errorData.error?.message || 'Unknown error'}`);
            }

            const data = await response.json();
            const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';

            console.debug(`LLM response text: [${text}]`);

            // Extract JSON from response
            jsonText = text.trim();
            if (jsonText.startsWith('```json')) {
                jsonText = jsonText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
            } else if (jsonText.startsWith('```')) {
                jsonText = jsonText.replace(/```\n?/g, '').trim();
            }

            const result = JSON.parse(jsonText);

            const llm_confidence = result.exists ? 'low' : result.confidence || 'low'; // LLM results are not accurate

            return {
                verified: result.exists,
                authorMatch: result.authorMatch !== false,
                yearMatch: result.yearMatch !== false,
                confidence: llm_confidence,
                foundTitle: result.foundTitle || '',
                foundAuthors: result.foundAuthors || '',
                canonicalUrl: result.canonicalUrl || '',
                message: result.message || 'Verification complete',
                warning: 'âš ï¸ LLM-verified results should be manually reviewed!',
                source: 'LLM (Gemini)',
                url: manualSearchUrl,
            };
        } catch (error) {
            console.error('LLM verification error: ', error);
            console.warn('JSON Text: ', jsonText)
            return {
                verified: false,
                message: 'Verification failed: ' + error.message,
                source: 'LLM',
                url: manualSearchUrl,
            };
        }
    }


    // Combined verification (CrossRef -> Semantic Scholar â†’ Google Scholar â†’ LLM)
    async function enhancedVerifyReference(ref) {
        // Check cache first
        const cached = verificationCache.get(ref);
        if (cached) {
            console.log('âœ“ Using cached result');
            return cached;
        }

        try {
            await rateLimiter.throttle();
        } catch (e) {
            console.log('Rate Limiter failed!');
        }

        let result;


        // 1. Try DOI first (most authoritative)
        if (ref.doi) {
            console.log('Trying DOI resolution...');
            const result = await verifyReferenceViaDOI(ref);
            if (result.verified) {
                console.log('âœ“ Verified via DOI');
                verificationCache.set(ref, result);
                return result;
            }
        }

        // 2. Try CrossRef title/author search
        console.log('Trying CrossRef...');
        result = await verifyReferenceViaCrossRef(ref);
        if (result.verified) {
            console.log('âœ“ Verified via CrossRef');
            verificationCache.set(ref, result);
            return result;
        }

        // 3. Try Semantic Scholar
        console.log('CrossRef failed, trying Semantic Scholar...');
        result = await verifyReferenceViaSemanticScholar(ref);
        if (result.verified) {
            console.log('âœ“ Verified via Semantic Scholar');
            verificationCache.set(ref, result);
            return result;
        }

        // 4. Try OpenAlex (alternative to Google Scholar)
        console.log('Semantic Scholar failed, trying OpenAlex...');
        result = await verifyReferenceViaOpenAlex(ref);
        if (result.verified) {
            console.log('âœ“ Verified via OpenAlex');
            verificationCache.set(ref, result);
            return result;
        }

        // 5. Add Google Scholar link for manual verification
        ref.googleScholarLink = getGoogleScholarUrl(ref.title);

        console.log('OpenAlex failed, trying GoogleScholar...');
        result = await verifyReferenceViaGoogleScholar(ref);
        if (result.verified) {
            console.log('âœ“ Verified via GoogleScholar');
            verificationCache.set(ref, result);
            return result;
        }

        // 6. Fallback to LLM with web search
        console.log('All API verifications failed, using LLM with web search...');
        result = await verifyReferenceWithLLM(ref);
        verificationCache.set(ref, result);

        return result;
    }

    // Process references button with LLM fallback and verification
    ui.processButton.addEventListener('click', async () => {
        const text = ui.referencesInput.value.trim();

        if (!text) {
            alert('Please paste references to process.');
            return;
        }

        ui.processButton.disabled = true;
        ui.processButton.innerHTML = 'Processing...';
        showProgress();

        const references = parseReferences(text);
        const extractedRefs = new Array(references.length); // Placeholder array

        // // 1. Run Local Extraction on ALL items first
        // const itemsNeedingLLM = [];
        //
        // references.forEach((ref, index) => {
        //     const extracted = extractReferenceInfo(ref);
        //     extractedRefs[index] = extracted;
        //
        //     // Check if local extraction was poor
        //     // (missing title OR missing authors) AND we have an API key
        //     if ((!extracted.title || !extracted.authors || extracted.title.length < 12) && storage.get('geminiApiKey')) {
        //         itemsNeedingLLM.push({
        //             index: index,
        //             text: ref
        //         });
        //     }
        // });
        //
        // // 2. Process LLM candidates in Batches (Chunk size of 15 is safe for tokens)
        // const BATCH_SIZE = 15;
        //
        // if (itemsNeedingLLM.length > 0) {
        //     for (let i = 0; i < itemsNeedingLLM.length; i += BATCH_SIZE) {
        //         // Get chunk
        //         const chunk = itemsNeedingLLM.slice(i, i + BATCH_SIZE);
        //         const chunkTexts = chunk.map(item => item.text);
        //
        //         updateProgress(i, itemsNeedingLLM.length, `LLM Extracting batch ${Math.ceil((i + 1) / BATCH_SIZE)}...`);
        //
        //         // Call the new batch function
        //         const llmResults = await extractBatchWithLLM(chunkTexts);
        //
        //         // Merge results back into main array
        //         llmResults.forEach((result, batchIdx) => {
        //             if (batchIdx < chunk.length) {
        //                 const originalIndex = chunk[batchIdx].index;
        //                 const existingData = extractedRefs[originalIndex];
        //
        //                 // Merge LLM data
        //                 extractedRefs[originalIndex] = {
        //                     original: existingData.original,
        //                     title: result.title || existingData.title,
        //                     authors: result.authors || existingData.authors,
        //                     doi: result.doi || existingData.doi,
        //                     url: result.url || existingData.url,
        //                     year: result.year || existingData.year,
        //                     warnings: [],
        //                     extractionMethod: 'llm'
        //                 };
        //
        //                 // Re-validate post-LLM
        //                 const ref = extractedRefs[originalIndex];
        //                 if (!ref.title) ref.warnings.push('Title could not be extracted');
        //                 if (!ref.authors) ref.warnings.push('Authors could not be extracted');
        //             }
        //         });
        //
        //         // Small delay to be nice to the API rate limit between batches
        //         if (i + BATCH_SIZE < itemsNeedingLLM.length) {
        //             await new Promise(r => setTimeout(r, 2000));
        //         }
        //     }
        // }

        // 1. Try LLM Extraction first (if API key is available)
        const BATCH_SIZE = 20;
        const hasApiKey = storage.get('geminiApiKey');

        if (hasApiKey) {
            for (let i = 0; i < references.length; i += BATCH_SIZE) {
                const chunk = references.slice(i, i + BATCH_SIZE);
                const chunkIndices = chunk.map((_, idx) => i + idx);

                updateProgress(i, references.length, `LLM Extracting batch ${Math.ceil((i + 1) / BATCH_SIZE)}...`);

                const llmResults = await extractBatchWithLLM(chunk);

                // Store LLM results
                llmResults.forEach((result, batchIdx) => {
                    if (batchIdx < chunk.length) {
                        const originalIndex = chunkIndices[batchIdx];
                        extractedRefs[originalIndex] = {
                            original: references[originalIndex],
                            title: result.title || '',
                            authors: result.authors || '',
                            doi: result.doi || '',
                            url: result.url || '',
                            year: result.year || '',
                            warnings: [],
                            extractionMethod: 'llm'
                        };
                    }
                });

                // Small delay to be nice to the API rate limit between batches
                if (i + BATCH_SIZE < references.length) {
                    await new Promise(r => setTimeout(r, 2000));
                }
            }
        }

        // 2. Run Local Extraction for items that failed LLM or if no API key
        references.forEach((ref, index) => {
            const llmResult = extractedRefs[index];

            // Check if LLM extraction was poor or didn't happen
            const llmFailed = !llmResult ||
                             !llmResult.title ||
                             !llmResult.authors ||
                             llmResult.title.trim().length < 12;

            if (llmFailed) {
                const localExtracted = extractReferenceInfo(ref);

                if (llmResult) {
                    // Merge: prefer LLM data if valid, fall back to local
                    const useLlmTitle = llmResult.title && llmResult.title.trim().length >= 12;
                    const useLlmAuthors = !!llmResult.authors;

                    extractedRefs[index] = {
                        original: ref,
                        title: useLlmTitle ? llmResult.title : localExtracted.title,
                        authors: useLlmAuthors ? llmResult.authors : localExtracted.authors,
                        doi: llmResult.doi || localExtracted.doi,
                        url: llmResult.url || localExtracted.url,
                        year: llmResult.year || localExtracted.year,
                        warnings: [],
                        extractionMethod: (useLlmTitle && useLlmAuthors) ? 'llm' : 'local_fallback'
                    };
                } else {
                    // No LLM result at all (e.g., no API key or total batch failure)
                    extractedRefs[index] = localExtracted;
                }
            }

            // Validate and add warnings
            const finalRef = extractedRefs[index];
            // Ensure warnings array exists
            finalRef.warnings = finalRef.warnings || [];
            if (!finalRef.title) finalRef.warnings.push('Title could not be extracted');
            if (!finalRef.authors) finalRef.warnings.push('Authors could not be extracted');
        });


        // Display initial results
        displayResults(extractedRefs);

        // Phase 3: Verify references (Sequential Verification Logic)
        // Check if we have references to verify
        if (extractedRefs.length > 0) {
            for (let i = 0; i < extractedRefs.length; i++) {
                updateProgress(i + 1, extractedRefs.length, `Verifying ${i + 1}/${extractedRefs.length}`);

                // Only verify if we successfully extracted at least a title
                // (trying to verify an empty object wastes resources)
                if (extractedRefs[i].title) {
                    const verification = await enhancedVerifyReference(extractedRefs[i]);
                    extractedRefs[i].verification = verification;

                    // Update the feedback cell in real-time
                    updateVerificationFeedback(i, verification);
                }
            }
        }

        hideProgress();

        ui.processButton.disabled = false;
        ui.processButton.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
            <path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.267.267 0 0 1 .02-.022z"/>
        </svg>
        Process & Verify References
    `;
    });


    // Export button
    ui.exportButton.addEventListener('click', exportToCSV);
</script>

<p class="subtitle">
    <strong>Note:</strong> This is a static web page that <strong>run locally</strong> in your browser â€” <em>Pasted
    References are sent to Gemini API</em>. If preferred, you can also download them as HTML files and run them offline
    or clone from <a href="https://github.com/janakanuwan/Web-Tools" target="_blank"
                     rel="noopener noreferrer">Web-Tools</a> (MIT License).
</p>

</body>
</html>